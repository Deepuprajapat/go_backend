// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/VI-IM/im_backend_go/ent/blogs"
	"github.com/VI-IM/im_backend_go/ent/developer"
	"github.com/VI-IM/im_backend_go/ent/leads"
	"github.com/VI-IM/im_backend_go/ent/location"
	"github.com/VI-IM/im_backend_go/ent/predicate"
	"github.com/VI-IM/im_backend_go/ent/project"
	"github.com/VI-IM/im_backend_go/ent/property"
	"github.com/VI-IM/im_backend_go/ent/schema"
	"github.com/VI-IM/im_backend_go/ent/staticsitedata"
	"github.com/VI-IM/im_backend_go/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlogs          = "Blogs"
	TypeDeveloper      = "Developer"
	TypeLeads          = "Leads"
	TypeLocation       = "Location"
	TypeProject        = "Project"
	TypeProperty       = "Property"
	TypeStaticSiteData = "StaticSiteData"
	TypeUser           = "User"
)

// BlogsMutation represents an operation that mutates the Blogs nodes in the graph.
type BlogsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	seo_meta_info     *schema.SEOMetaInfo
	blog_url          *string
	blog_content      *schema.BlogContent
	is_priority       *bool
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	updated_by        *int
	clearedupdated_by bool
	done              bool
	oldValue          func(context.Context) (*Blogs, error)
	predicates        []predicate.Blogs
}

var _ ent.Mutation = (*BlogsMutation)(nil)

// blogsOption allows management of the mutation configuration using functional options.
type blogsOption func(*BlogsMutation)

// newBlogsMutation creates new mutation for the Blogs entity.
func newBlogsMutation(c config, op Op, opts ...blogsOption) *BlogsMutation {
	m := &BlogsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogsID sets the ID field of the mutation.
func withBlogsID(id int) blogsOption {
	return func(m *BlogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Blogs
		)
		m.oldValue = func(ctx context.Context) (*Blogs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blogs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogs sets the old Blogs of the mutation.
func withBlogs(node *Blogs) blogsOption {
	return func(m *BlogsMutation) {
		m.oldValue = func(context.Context) (*Blogs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blogs entities.
func (m *BlogsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blogs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeoMetaInfo sets the "seo_meta_info" field.
func (m *BlogsMutation) SetSeoMetaInfo(smi schema.SEOMetaInfo) {
	m.seo_meta_info = &smi
}

// SeoMetaInfo returns the value of the "seo_meta_info" field in the mutation.
func (m *BlogsMutation) SeoMetaInfo() (r schema.SEOMetaInfo, exists bool) {
	v := m.seo_meta_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSeoMetaInfo returns the old "seo_meta_info" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldSeoMetaInfo(ctx context.Context) (v schema.SEOMetaInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeoMetaInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeoMetaInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeoMetaInfo: %w", err)
	}
	return oldValue.SeoMetaInfo, nil
}

// ResetSeoMetaInfo resets all changes to the "seo_meta_info" field.
func (m *BlogsMutation) ResetSeoMetaInfo() {
	m.seo_meta_info = nil
}

// SetBlogURL sets the "blog_url" field.
func (m *BlogsMutation) SetBlogURL(s string) {
	m.blog_url = &s
}

// BlogURL returns the value of the "blog_url" field in the mutation.
func (m *BlogsMutation) BlogURL() (r string, exists bool) {
	v := m.blog_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogURL returns the old "blog_url" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldBlogURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogURL: %w", err)
	}
	return oldValue.BlogURL, nil
}

// ResetBlogURL resets all changes to the "blog_url" field.
func (m *BlogsMutation) ResetBlogURL() {
	m.blog_url = nil
}

// SetBlogContent sets the "blog_content" field.
func (m *BlogsMutation) SetBlogContent(sc schema.BlogContent) {
	m.blog_content = &sc
}

// BlogContent returns the value of the "blog_content" field in the mutation.
func (m *BlogsMutation) BlogContent() (r schema.BlogContent, exists bool) {
	v := m.blog_content
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogContent returns the old "blog_content" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldBlogContent(ctx context.Context) (v schema.BlogContent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogContent: %w", err)
	}
	return oldValue.BlogContent, nil
}

// ResetBlogContent resets all changes to the "blog_content" field.
func (m *BlogsMutation) ResetBlogContent() {
	m.blog_content = nil
}

// SetIsPriority sets the "is_priority" field.
func (m *BlogsMutation) SetIsPriority(b bool) {
	m.is_priority = &b
}

// IsPriority returns the value of the "is_priority" field in the mutation.
func (m *BlogsMutation) IsPriority() (r bool, exists bool) {
	v := m.is_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPriority returns the old "is_priority" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldIsPriority(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPriority: %w", err)
	}
	return oldValue.IsPriority, nil
}

// ResetIsPriority resets all changes to the "is_priority" field.
func (m *BlogsMutation) ResetIsPriority() {
	m.is_priority = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blogs entity.
// If the Blogs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *BlogsMutation) SetUpdatedByID(id int) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *BlogsMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *BlogsMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *BlogsMutation) UpdatedByID() (id int, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *BlogsMutation) UpdatedByIDs() (ids []int) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *BlogsMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// Where appends a list predicates to the BlogsMutation builder.
func (m *BlogsMutation) Where(ps ...predicate.Blogs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blogs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blogs).
func (m *BlogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.seo_meta_info != nil {
		fields = append(fields, blogs.FieldSeoMetaInfo)
	}
	if m.blog_url != nil {
		fields = append(fields, blogs.FieldBlogURL)
	}
	if m.blog_content != nil {
		fields = append(fields, blogs.FieldBlogContent)
	}
	if m.is_priority != nil {
		fields = append(fields, blogs.FieldIsPriority)
	}
	if m.created_at != nil {
		fields = append(fields, blogs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogs.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogs.FieldSeoMetaInfo:
		return m.SeoMetaInfo()
	case blogs.FieldBlogURL:
		return m.BlogURL()
	case blogs.FieldBlogContent:
		return m.BlogContent()
	case blogs.FieldIsPriority:
		return m.IsPriority()
	case blogs.FieldCreatedAt:
		return m.CreatedAt()
	case blogs.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogs.FieldSeoMetaInfo:
		return m.OldSeoMetaInfo(ctx)
	case blogs.FieldBlogURL:
		return m.OldBlogURL(ctx)
	case blogs.FieldBlogContent:
		return m.OldBlogContent(ctx)
	case blogs.FieldIsPriority:
		return m.OldIsPriority(ctx)
	case blogs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Blogs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogs.FieldSeoMetaInfo:
		v, ok := value.(schema.SEOMetaInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeoMetaInfo(v)
		return nil
	case blogs.FieldBlogURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogURL(v)
		return nil
	case blogs.FieldBlogContent:
		v, ok := value.(schema.BlogContent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogContent(v)
		return nil
	case blogs.FieldIsPriority:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPriority(v)
		return nil
	case blogs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Blogs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blogs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogsMutation) ResetField(name string) error {
	switch name {
	case blogs.FieldSeoMetaInfo:
		m.ResetSeoMetaInfo()
		return nil
	case blogs.FieldBlogURL:
		m.ResetBlogURL()
		return nil
	case blogs.FieldBlogContent:
		m.ResetBlogContent()
		return nil
	case blogs.FieldIsPriority:
		m.ResetIsPriority()
		return nil
	case blogs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Blogs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.updated_by != nil {
		edges = append(edges, blogs.EdgeUpdatedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogs.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedupdated_by {
		edges = append(edges, blogs.EdgeUpdatedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogsMutation) EdgeCleared(name string) bool {
	switch name {
	case blogs.EdgeUpdatedBy:
		return m.clearedupdated_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogsMutation) ClearEdge(name string) error {
	switch name {
	case blogs.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Blogs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogsMutation) ResetEdge(name string) error {
	switch name {
	case blogs.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Blogs edge %s", name)
}

// DeveloperMutation represents an operation that mutates the Developer nodes in the graph.
type DeveloperMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	legal_name          *string
	url                 *string
	established_year    *int
	addestablished_year *int
	project_count       *int
	addproject_count    *int
	contact_info        *schema.DeveloperContactInfo
	media_content       *schema.DeveloperMediaContent
	seo_meta            *schema.DeveloperSEOMeta
	is_active           *bool
	is_verified         *bool
	search_context      *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	projects            map[int]struct{}
	removedprojects     map[int]struct{}
	clearedprojects     bool
	done                bool
	oldValue            func(context.Context) (*Developer, error)
	predicates          []predicate.Developer
}

var _ ent.Mutation = (*DeveloperMutation)(nil)

// developerOption allows management of the mutation configuration using functional options.
type developerOption func(*DeveloperMutation)

// newDeveloperMutation creates new mutation for the Developer entity.
func newDeveloperMutation(c config, op Op, opts ...developerOption) *DeveloperMutation {
	m := &DeveloperMutation{
		config:        c,
		op:            op,
		typ:           TypeDeveloper,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeveloperID sets the ID field of the mutation.
func withDeveloperID(id int) developerOption {
	return func(m *DeveloperMutation) {
		var (
			err   error
			once  sync.Once
			value *Developer
		)
		m.oldValue = func(ctx context.Context) (*Developer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Developer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeveloper sets the old Developer of the mutation.
func withDeveloper(node *Developer) developerOption {
	return func(m *DeveloperMutation) {
		m.oldValue = func(context.Context) (*Developer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeveloperMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeveloperMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Developer entities.
func (m *DeveloperMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeveloperMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeveloperMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Developer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DeveloperMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeveloperMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeveloperMutation) ResetName() {
	m.name = nil
}

// SetLegalName sets the "legal_name" field.
func (m *DeveloperMutation) SetLegalName(s string) {
	m.legal_name = &s
}

// LegalName returns the value of the "legal_name" field in the mutation.
func (m *DeveloperMutation) LegalName() (r string, exists bool) {
	v := m.legal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalName returns the old "legal_name" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldLegalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalName: %w", err)
	}
	return oldValue.LegalName, nil
}

// ResetLegalName resets all changes to the "legal_name" field.
func (m *DeveloperMutation) ResetLegalName() {
	m.legal_name = nil
}

// SetURL sets the "url" field.
func (m *DeveloperMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DeveloperMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DeveloperMutation) ResetURL() {
	m.url = nil
}

// SetEstablishedYear sets the "established_year" field.
func (m *DeveloperMutation) SetEstablishedYear(i int) {
	m.established_year = &i
	m.addestablished_year = nil
}

// EstablishedYear returns the value of the "established_year" field in the mutation.
func (m *DeveloperMutation) EstablishedYear() (r int, exists bool) {
	v := m.established_year
	if v == nil {
		return
	}
	return *v, true
}

// OldEstablishedYear returns the old "established_year" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldEstablishedYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstablishedYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstablishedYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstablishedYear: %w", err)
	}
	return oldValue.EstablishedYear, nil
}

// AddEstablishedYear adds i to the "established_year" field.
func (m *DeveloperMutation) AddEstablishedYear(i int) {
	if m.addestablished_year != nil {
		*m.addestablished_year += i
	} else {
		m.addestablished_year = &i
	}
}

// AddedEstablishedYear returns the value that was added to the "established_year" field in this mutation.
func (m *DeveloperMutation) AddedEstablishedYear() (r int, exists bool) {
	v := m.addestablished_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstablishedYear resets all changes to the "established_year" field.
func (m *DeveloperMutation) ResetEstablishedYear() {
	m.established_year = nil
	m.addestablished_year = nil
}

// SetProjectCount sets the "project_count" field.
func (m *DeveloperMutation) SetProjectCount(i int) {
	m.project_count = &i
	m.addproject_count = nil
}

// ProjectCount returns the value of the "project_count" field in the mutation.
func (m *DeveloperMutation) ProjectCount() (r int, exists bool) {
	v := m.project_count
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectCount returns the old "project_count" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldProjectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectCount: %w", err)
	}
	return oldValue.ProjectCount, nil
}

// AddProjectCount adds i to the "project_count" field.
func (m *DeveloperMutation) AddProjectCount(i int) {
	if m.addproject_count != nil {
		*m.addproject_count += i
	} else {
		m.addproject_count = &i
	}
}

// AddedProjectCount returns the value that was added to the "project_count" field in this mutation.
func (m *DeveloperMutation) AddedProjectCount() (r int, exists bool) {
	v := m.addproject_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectCount resets all changes to the "project_count" field.
func (m *DeveloperMutation) ResetProjectCount() {
	m.project_count = nil
	m.addproject_count = nil
}

// SetContactInfo sets the "contact_info" field.
func (m *DeveloperMutation) SetContactInfo(sci schema.DeveloperContactInfo) {
	m.contact_info = &sci
}

// ContactInfo returns the value of the "contact_info" field in the mutation.
func (m *DeveloperMutation) ContactInfo() (r schema.DeveloperContactInfo, exists bool) {
	v := m.contact_info
	if v == nil {
		return
	}
	return *v, true
}

// OldContactInfo returns the old "contact_info" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldContactInfo(ctx context.Context) (v schema.DeveloperContactInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactInfo: %w", err)
	}
	return oldValue.ContactInfo, nil
}

// ResetContactInfo resets all changes to the "contact_info" field.
func (m *DeveloperMutation) ResetContactInfo() {
	m.contact_info = nil
}

// SetMediaContent sets the "media_content" field.
func (m *DeveloperMutation) SetMediaContent(smc schema.DeveloperMediaContent) {
	m.media_content = &smc
}

// MediaContent returns the value of the "media_content" field in the mutation.
func (m *DeveloperMutation) MediaContent() (r schema.DeveloperMediaContent, exists bool) {
	v := m.media_content
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaContent returns the old "media_content" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldMediaContent(ctx context.Context) (v schema.DeveloperMediaContent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaContent: %w", err)
	}
	return oldValue.MediaContent, nil
}

// ResetMediaContent resets all changes to the "media_content" field.
func (m *DeveloperMutation) ResetMediaContent() {
	m.media_content = nil
}

// SetSeoMeta sets the "seo_meta" field.
func (m *DeveloperMutation) SetSeoMeta(ssm schema.DeveloperSEOMeta) {
	m.seo_meta = &ssm
}

// SeoMeta returns the value of the "seo_meta" field in the mutation.
func (m *DeveloperMutation) SeoMeta() (r schema.DeveloperSEOMeta, exists bool) {
	v := m.seo_meta
	if v == nil {
		return
	}
	return *v, true
}

// OldSeoMeta returns the old "seo_meta" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldSeoMeta(ctx context.Context) (v schema.DeveloperSEOMeta, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeoMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeoMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeoMeta: %w", err)
	}
	return oldValue.SeoMeta, nil
}

// ResetSeoMeta resets all changes to the "seo_meta" field.
func (m *DeveloperMutation) ResetSeoMeta() {
	m.seo_meta = nil
}

// SetIsActive sets the "is_active" field.
func (m *DeveloperMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *DeveloperMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *DeveloperMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *DeveloperMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *DeveloperMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *DeveloperMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetSearchContext sets the "search_context" field.
func (m *DeveloperMutation) SetSearchContext(s string) {
	m.search_context = &s
}

// SearchContext returns the value of the "search_context" field in the mutation.
func (m *DeveloperMutation) SearchContext() (r string, exists bool) {
	v := m.search_context
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchContext returns the old "search_context" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldSearchContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchContext: %w", err)
	}
	return oldValue.SearchContext, nil
}

// ResetSearchContext resets all changes to the "search_context" field.
func (m *DeveloperMutation) ResetSearchContext() {
	m.search_context = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeveloperMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeveloperMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeveloperMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeveloperMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeveloperMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Developer entity.
// If the Developer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeveloperMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeveloperMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *DeveloperMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *DeveloperMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *DeveloperMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *DeveloperMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *DeveloperMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *DeveloperMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *DeveloperMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the DeveloperMutation builder.
func (m *DeveloperMutation) Where(ps ...predicate.Developer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeveloperMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeveloperMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Developer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeveloperMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeveloperMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Developer).
func (m *DeveloperMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeveloperMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, developer.FieldName)
	}
	if m.legal_name != nil {
		fields = append(fields, developer.FieldLegalName)
	}
	if m.url != nil {
		fields = append(fields, developer.FieldURL)
	}
	if m.established_year != nil {
		fields = append(fields, developer.FieldEstablishedYear)
	}
	if m.project_count != nil {
		fields = append(fields, developer.FieldProjectCount)
	}
	if m.contact_info != nil {
		fields = append(fields, developer.FieldContactInfo)
	}
	if m.media_content != nil {
		fields = append(fields, developer.FieldMediaContent)
	}
	if m.seo_meta != nil {
		fields = append(fields, developer.FieldSeoMeta)
	}
	if m.is_active != nil {
		fields = append(fields, developer.FieldIsActive)
	}
	if m.is_verified != nil {
		fields = append(fields, developer.FieldIsVerified)
	}
	if m.search_context != nil {
		fields = append(fields, developer.FieldSearchContext)
	}
	if m.created_at != nil {
		fields = append(fields, developer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, developer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeveloperMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case developer.FieldName:
		return m.Name()
	case developer.FieldLegalName:
		return m.LegalName()
	case developer.FieldURL:
		return m.URL()
	case developer.FieldEstablishedYear:
		return m.EstablishedYear()
	case developer.FieldProjectCount:
		return m.ProjectCount()
	case developer.FieldContactInfo:
		return m.ContactInfo()
	case developer.FieldMediaContent:
		return m.MediaContent()
	case developer.FieldSeoMeta:
		return m.SeoMeta()
	case developer.FieldIsActive:
		return m.IsActive()
	case developer.FieldIsVerified:
		return m.IsVerified()
	case developer.FieldSearchContext:
		return m.SearchContext()
	case developer.FieldCreatedAt:
		return m.CreatedAt()
	case developer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeveloperMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case developer.FieldName:
		return m.OldName(ctx)
	case developer.FieldLegalName:
		return m.OldLegalName(ctx)
	case developer.FieldURL:
		return m.OldURL(ctx)
	case developer.FieldEstablishedYear:
		return m.OldEstablishedYear(ctx)
	case developer.FieldProjectCount:
		return m.OldProjectCount(ctx)
	case developer.FieldContactInfo:
		return m.OldContactInfo(ctx)
	case developer.FieldMediaContent:
		return m.OldMediaContent(ctx)
	case developer.FieldSeoMeta:
		return m.OldSeoMeta(ctx)
	case developer.FieldIsActive:
		return m.OldIsActive(ctx)
	case developer.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case developer.FieldSearchContext:
		return m.OldSearchContext(ctx)
	case developer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case developer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Developer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeveloperMutation) SetField(name string, value ent.Value) error {
	switch name {
	case developer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case developer.FieldLegalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalName(v)
		return nil
	case developer.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case developer.FieldEstablishedYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstablishedYear(v)
		return nil
	case developer.FieldProjectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectCount(v)
		return nil
	case developer.FieldContactInfo:
		v, ok := value.(schema.DeveloperContactInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactInfo(v)
		return nil
	case developer.FieldMediaContent:
		v, ok := value.(schema.DeveloperMediaContent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaContent(v)
		return nil
	case developer.FieldSeoMeta:
		v, ok := value.(schema.DeveloperSEOMeta)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeoMeta(v)
		return nil
	case developer.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case developer.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case developer.FieldSearchContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchContext(v)
		return nil
	case developer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case developer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Developer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeveloperMutation) AddedFields() []string {
	var fields []string
	if m.addestablished_year != nil {
		fields = append(fields, developer.FieldEstablishedYear)
	}
	if m.addproject_count != nil {
		fields = append(fields, developer.FieldProjectCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeveloperMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case developer.FieldEstablishedYear:
		return m.AddedEstablishedYear()
	case developer.FieldProjectCount:
		return m.AddedProjectCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeveloperMutation) AddField(name string, value ent.Value) error {
	switch name {
	case developer.FieldEstablishedYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstablishedYear(v)
		return nil
	case developer.FieldProjectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectCount(v)
		return nil
	}
	return fmt.Errorf("unknown Developer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeveloperMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeveloperMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeveloperMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Developer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeveloperMutation) ResetField(name string) error {
	switch name {
	case developer.FieldName:
		m.ResetName()
		return nil
	case developer.FieldLegalName:
		m.ResetLegalName()
		return nil
	case developer.FieldURL:
		m.ResetURL()
		return nil
	case developer.FieldEstablishedYear:
		m.ResetEstablishedYear()
		return nil
	case developer.FieldProjectCount:
		m.ResetProjectCount()
		return nil
	case developer.FieldContactInfo:
		m.ResetContactInfo()
		return nil
	case developer.FieldMediaContent:
		m.ResetMediaContent()
		return nil
	case developer.FieldSeoMeta:
		m.ResetSeoMeta()
		return nil
	case developer.FieldIsActive:
		m.ResetIsActive()
		return nil
	case developer.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case developer.FieldSearchContext:
		m.ResetSearchContext()
		return nil
	case developer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case developer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Developer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeveloperMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, developer.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeveloperMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case developer.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeveloperMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, developer.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeveloperMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case developer.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeveloperMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, developer.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeveloperMutation) EdgeCleared(name string) bool {
	switch name {
	case developer.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeveloperMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Developer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeveloperMutation) ResetEdge(name string) error {
	switch name {
	case developer.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Developer edge %s", name)
}

// LeadsMutation represents an operation that mutates the Leads nodes in the graph.
type LeadsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	email           *string
	frequency       *string
	name            *string
	otp             *string
	phone           *string
	project_name    *string
	source          *string
	message         *string
	user_type       *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	property        *int
	clearedproperty bool
	done            bool
	oldValue        func(context.Context) (*Leads, error)
	predicates      []predicate.Leads
}

var _ ent.Mutation = (*LeadsMutation)(nil)

// leadsOption allows management of the mutation configuration using functional options.
type leadsOption func(*LeadsMutation)

// newLeadsMutation creates new mutation for the Leads entity.
func newLeadsMutation(c config, op Op, opts ...leadsOption) *LeadsMutation {
	m := &LeadsMutation{
		config:        c,
		op:            op,
		typ:           TypeLeads,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadsID sets the ID field of the mutation.
func withLeadsID(id int) leadsOption {
	return func(m *LeadsMutation) {
		var (
			err   error
			once  sync.Once
			value *Leads
		)
		m.oldValue = func(ctx context.Context) (*Leads, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Leads.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeads sets the old Leads of the mutation.
func withLeads(node *Leads) leadsOption {
	return func(m *LeadsMutation) {
		m.oldValue = func(context.Context) (*Leads, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Leads entities.
func (m *LeadsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Leads.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *LeadsMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LeadsMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *LeadsMutation) ResetEmail() {
	m.email = nil
}

// SetFrequency sets the "frequency" field.
func (m *LeadsMutation) SetFrequency(s string) {
	m.frequency = &s
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *LeadsMutation) Frequency() (r string, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldFrequency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ClearFrequency clears the value of the "frequency" field.
func (m *LeadsMutation) ClearFrequency() {
	m.frequency = nil
	m.clearedFields[leads.FieldFrequency] = struct{}{}
}

// FrequencyCleared returns if the "frequency" field was cleared in this mutation.
func (m *LeadsMutation) FrequencyCleared() bool {
	_, ok := m.clearedFields[leads.FieldFrequency]
	return ok
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *LeadsMutation) ResetFrequency() {
	m.frequency = nil
	delete(m.clearedFields, leads.FieldFrequency)
}

// SetName sets the "name" field.
func (m *LeadsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LeadsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LeadsMutation) ResetName() {
	m.name = nil
}

// SetOtp sets the "otp" field.
func (m *LeadsMutation) SetOtp(s string) {
	m.otp = &s
}

// Otp returns the value of the "otp" field in the mutation.
func (m *LeadsMutation) Otp() (r string, exists bool) {
	v := m.otp
	if v == nil {
		return
	}
	return *v, true
}

// OldOtp returns the old "otp" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldOtp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtp: %w", err)
	}
	return oldValue.Otp, nil
}

// ClearOtp clears the value of the "otp" field.
func (m *LeadsMutation) ClearOtp() {
	m.otp = nil
	m.clearedFields[leads.FieldOtp] = struct{}{}
}

// OtpCleared returns if the "otp" field was cleared in this mutation.
func (m *LeadsMutation) OtpCleared() bool {
	_, ok := m.clearedFields[leads.FieldOtp]
	return ok
}

// ResetOtp resets all changes to the "otp" field.
func (m *LeadsMutation) ResetOtp() {
	m.otp = nil
	delete(m.clearedFields, leads.FieldOtp)
}

// SetPhone sets the "phone" field.
func (m *LeadsMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *LeadsMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *LeadsMutation) ResetPhone() {
	m.phone = nil
}

// SetProjectName sets the "project_name" field.
func (m *LeadsMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *LeadsMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ClearProjectName clears the value of the "project_name" field.
func (m *LeadsMutation) ClearProjectName() {
	m.project_name = nil
	m.clearedFields[leads.FieldProjectName] = struct{}{}
}

// ProjectNameCleared returns if the "project_name" field was cleared in this mutation.
func (m *LeadsMutation) ProjectNameCleared() bool {
	_, ok := m.clearedFields[leads.FieldProjectName]
	return ok
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *LeadsMutation) ResetProjectName() {
	m.project_name = nil
	delete(m.clearedFields, leads.FieldProjectName)
}

// SetSource sets the "source" field.
func (m *LeadsMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *LeadsMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *LeadsMutation) ClearSource() {
	m.source = nil
	m.clearedFields[leads.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *LeadsMutation) SourceCleared() bool {
	_, ok := m.clearedFields[leads.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *LeadsMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, leads.FieldSource)
}

// SetMessage sets the "message" field.
func (m *LeadsMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *LeadsMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *LeadsMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[leads.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *LeadsMutation) MessageCleared() bool {
	_, ok := m.clearedFields[leads.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *LeadsMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, leads.FieldMessage)
}

// SetUserType sets the "user_type" field.
func (m *LeadsMutation) SetUserType(s string) {
	m.user_type = &s
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *LeadsMutation) UserType() (r string, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldUserType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ClearUserType clears the value of the "user_type" field.
func (m *LeadsMutation) ClearUserType() {
	m.user_type = nil
	m.clearedFields[leads.FieldUserType] = struct{}{}
}

// UserTypeCleared returns if the "user_type" field was cleared in this mutation.
func (m *LeadsMutation) UserTypeCleared() bool {
	_, ok := m.clearedFields[leads.FieldUserType]
	return ok
}

// ResetUserType resets all changes to the "user_type" field.
func (m *LeadsMutation) ResetUserType() {
	m.user_type = nil
	delete(m.clearedFields, leads.FieldUserType)
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeadsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeadsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Leads entity.
// If the Leads object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeadsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPropertyID sets the "property" edge to the Property entity by id.
func (m *LeadsMutation) SetPropertyID(id int) {
	m.property = &id
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *LeadsMutation) ClearProperty() {
	m.clearedproperty = true
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *LeadsMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyID returns the "property" edge ID in the mutation.
func (m *LeadsMutation) PropertyID() (id int, exists bool) {
	if m.property != nil {
		return *m.property, true
	}
	return
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *LeadsMutation) PropertyIDs() (ids []int) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *LeadsMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// Where appends a list predicates to the LeadsMutation builder.
func (m *LeadsMutation) Where(ps ...predicate.Leads) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Leads, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Leads).
func (m *LeadsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.email != nil {
		fields = append(fields, leads.FieldEmail)
	}
	if m.frequency != nil {
		fields = append(fields, leads.FieldFrequency)
	}
	if m.name != nil {
		fields = append(fields, leads.FieldName)
	}
	if m.otp != nil {
		fields = append(fields, leads.FieldOtp)
	}
	if m.phone != nil {
		fields = append(fields, leads.FieldPhone)
	}
	if m.project_name != nil {
		fields = append(fields, leads.FieldProjectName)
	}
	if m.source != nil {
		fields = append(fields, leads.FieldSource)
	}
	if m.message != nil {
		fields = append(fields, leads.FieldMessage)
	}
	if m.user_type != nil {
		fields = append(fields, leads.FieldUserType)
	}
	if m.created_at != nil {
		fields = append(fields, leads.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, leads.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leads.FieldEmail:
		return m.Email()
	case leads.FieldFrequency:
		return m.Frequency()
	case leads.FieldName:
		return m.Name()
	case leads.FieldOtp:
		return m.Otp()
	case leads.FieldPhone:
		return m.Phone()
	case leads.FieldProjectName:
		return m.ProjectName()
	case leads.FieldSource:
		return m.Source()
	case leads.FieldMessage:
		return m.Message()
	case leads.FieldUserType:
		return m.UserType()
	case leads.FieldCreatedAt:
		return m.CreatedAt()
	case leads.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leads.FieldEmail:
		return m.OldEmail(ctx)
	case leads.FieldFrequency:
		return m.OldFrequency(ctx)
	case leads.FieldName:
		return m.OldName(ctx)
	case leads.FieldOtp:
		return m.OldOtp(ctx)
	case leads.FieldPhone:
		return m.OldPhone(ctx)
	case leads.FieldProjectName:
		return m.OldProjectName(ctx)
	case leads.FieldSource:
		return m.OldSource(ctx)
	case leads.FieldMessage:
		return m.OldMessage(ctx)
	case leads.FieldUserType:
		return m.OldUserType(ctx)
	case leads.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case leads.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Leads field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leads.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case leads.FieldFrequency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case leads.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case leads.FieldOtp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtp(v)
		return nil
	case leads.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case leads.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case leads.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case leads.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case leads.FieldUserType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case leads.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case leads.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Leads field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Leads numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(leads.FieldFrequency) {
		fields = append(fields, leads.FieldFrequency)
	}
	if m.FieldCleared(leads.FieldOtp) {
		fields = append(fields, leads.FieldOtp)
	}
	if m.FieldCleared(leads.FieldProjectName) {
		fields = append(fields, leads.FieldProjectName)
	}
	if m.FieldCleared(leads.FieldSource) {
		fields = append(fields, leads.FieldSource)
	}
	if m.FieldCleared(leads.FieldMessage) {
		fields = append(fields, leads.FieldMessage)
	}
	if m.FieldCleared(leads.FieldUserType) {
		fields = append(fields, leads.FieldUserType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadsMutation) ClearField(name string) error {
	switch name {
	case leads.FieldFrequency:
		m.ClearFrequency()
		return nil
	case leads.FieldOtp:
		m.ClearOtp()
		return nil
	case leads.FieldProjectName:
		m.ClearProjectName()
		return nil
	case leads.FieldSource:
		m.ClearSource()
		return nil
	case leads.FieldMessage:
		m.ClearMessage()
		return nil
	case leads.FieldUserType:
		m.ClearUserType()
		return nil
	}
	return fmt.Errorf("unknown Leads nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadsMutation) ResetField(name string) error {
	switch name {
	case leads.FieldEmail:
		m.ResetEmail()
		return nil
	case leads.FieldFrequency:
		m.ResetFrequency()
		return nil
	case leads.FieldName:
		m.ResetName()
		return nil
	case leads.FieldOtp:
		m.ResetOtp()
		return nil
	case leads.FieldPhone:
		m.ResetPhone()
		return nil
	case leads.FieldProjectName:
		m.ResetProjectName()
		return nil
	case leads.FieldSource:
		m.ResetSource()
		return nil
	case leads.FieldMessage:
		m.ResetMessage()
		return nil
	case leads.FieldUserType:
		m.ResetUserType()
		return nil
	case leads.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case leads.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Leads field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.property != nil {
		edges = append(edges, leads.EdgeProperty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leads.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproperty {
		edges = append(edges, leads.EdgeProperty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadsMutation) EdgeCleared(name string) bool {
	switch name {
	case leads.EdgeProperty:
		return m.clearedproperty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadsMutation) ClearEdge(name string) error {
	switch name {
	case leads.EdgeProperty:
		m.ClearProperty()
		return nil
	}
	return fmt.Errorf("unknown Leads unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadsMutation) ResetEdge(name string) error {
	switch name {
	case leads.EdgeProperty:
		m.ResetProperty()
		return nil
	}
	return fmt.Errorf("unknown Leads edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	locality_name        *string
	city                 *string
	state                *string
	phone_number         *string
	country              *string
	pincode              *string
	area_type            *string
	latitude             *float64
	addlatitude          *float64
	longitude            *float64
	addlongitude         *float64
	google_map_link      *string
	location_description *string
	nearby_landmarks     *schema.NearbyLandmarks
	connectivity         *schema.LocationConnectivity
	is_active            *bool
	slug                 *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	projects             map[int]struct{}
	removedprojects      map[int]struct{}
	clearedprojects      bool
	done                 bool
	oldValue             func(context.Context) (*Location, error)
	predicates           []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLocalityName sets the "locality_name" field.
func (m *LocationMutation) SetLocalityName(s string) {
	m.locality_name = &s
}

// LocalityName returns the value of the "locality_name" field in the mutation.
func (m *LocationMutation) LocalityName() (r string, exists bool) {
	v := m.locality_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalityName returns the old "locality_name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLocalityName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalityName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalityName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalityName: %w", err)
	}
	return oldValue.LocalityName, nil
}

// ResetLocalityName resets all changes to the "locality_name" field.
func (m *LocationMutation) ResetLocalityName() {
	m.locality_name = nil
}

// SetCity sets the "city" field.
func (m *LocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *LocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *LocationMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *LocationMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *LocationMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *LocationMutation) ResetState() {
	m.state = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *LocationMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *LocationMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *LocationMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetCountry sets the "country" field.
func (m *LocationMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *LocationMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *LocationMutation) ResetCountry() {
	m.country = nil
}

// SetPincode sets the "pincode" field.
func (m *LocationMutation) SetPincode(s string) {
	m.pincode = &s
}

// Pincode returns the value of the "pincode" field in the mutation.
func (m *LocationMutation) Pincode() (r string, exists bool) {
	v := m.pincode
	if v == nil {
		return
	}
	return *v, true
}

// OldPincode returns the old "pincode" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPincode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPincode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPincode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPincode: %w", err)
	}
	return oldValue.Pincode, nil
}

// ResetPincode resets all changes to the "pincode" field.
func (m *LocationMutation) ResetPincode() {
	m.pincode = nil
}

// SetAreaType sets the "area_type" field.
func (m *LocationMutation) SetAreaType(s string) {
	m.area_type = &s
}

// AreaType returns the value of the "area_type" field in the mutation.
func (m *LocationMutation) AreaType() (r string, exists bool) {
	v := m.area_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaType returns the old "area_type" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAreaType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaType: %w", err)
	}
	return oldValue.AreaType, nil
}

// ResetAreaType resets all changes to the "area_type" field.
func (m *LocationMutation) ResetAreaType() {
	m.area_type = nil
}

// SetLatitude sets the "latitude" field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *LocationMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[location.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *LocationMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, location.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *LocationMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[location.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *LocationMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, location.FieldLongitude)
}

// SetGoogleMapLink sets the "google_map_link" field.
func (m *LocationMutation) SetGoogleMapLink(s string) {
	m.google_map_link = &s
}

// GoogleMapLink returns the value of the "google_map_link" field in the mutation.
func (m *LocationMutation) GoogleMapLink() (r string, exists bool) {
	v := m.google_map_link
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleMapLink returns the old "google_map_link" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldGoogleMapLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleMapLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleMapLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleMapLink: %w", err)
	}
	return oldValue.GoogleMapLink, nil
}

// ClearGoogleMapLink clears the value of the "google_map_link" field.
func (m *LocationMutation) ClearGoogleMapLink() {
	m.google_map_link = nil
	m.clearedFields[location.FieldGoogleMapLink] = struct{}{}
}

// GoogleMapLinkCleared returns if the "google_map_link" field was cleared in this mutation.
func (m *LocationMutation) GoogleMapLinkCleared() bool {
	_, ok := m.clearedFields[location.FieldGoogleMapLink]
	return ok
}

// ResetGoogleMapLink resets all changes to the "google_map_link" field.
func (m *LocationMutation) ResetGoogleMapLink() {
	m.google_map_link = nil
	delete(m.clearedFields, location.FieldGoogleMapLink)
}

// SetLocationDescription sets the "location_description" field.
func (m *LocationMutation) SetLocationDescription(s string) {
	m.location_description = &s
}

// LocationDescription returns the value of the "location_description" field in the mutation.
func (m *LocationMutation) LocationDescription() (r string, exists bool) {
	v := m.location_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationDescription returns the old "location_description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLocationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationDescription: %w", err)
	}
	return oldValue.LocationDescription, nil
}

// ClearLocationDescription clears the value of the "location_description" field.
func (m *LocationMutation) ClearLocationDescription() {
	m.location_description = nil
	m.clearedFields[location.FieldLocationDescription] = struct{}{}
}

// LocationDescriptionCleared returns if the "location_description" field was cleared in this mutation.
func (m *LocationMutation) LocationDescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldLocationDescription]
	return ok
}

// ResetLocationDescription resets all changes to the "location_description" field.
func (m *LocationMutation) ResetLocationDescription() {
	m.location_description = nil
	delete(m.clearedFields, location.FieldLocationDescription)
}

// SetNearbyLandmarks sets the "nearby_landmarks" field.
func (m *LocationMutation) SetNearbyLandmarks(sl schema.NearbyLandmarks) {
	m.nearby_landmarks = &sl
}

// NearbyLandmarks returns the value of the "nearby_landmarks" field in the mutation.
func (m *LocationMutation) NearbyLandmarks() (r schema.NearbyLandmarks, exists bool) {
	v := m.nearby_landmarks
	if v == nil {
		return
	}
	return *v, true
}

// OldNearbyLandmarks returns the old "nearby_landmarks" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldNearbyLandmarks(ctx context.Context) (v schema.NearbyLandmarks, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNearbyLandmarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNearbyLandmarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNearbyLandmarks: %w", err)
	}
	return oldValue.NearbyLandmarks, nil
}

// ResetNearbyLandmarks resets all changes to the "nearby_landmarks" field.
func (m *LocationMutation) ResetNearbyLandmarks() {
	m.nearby_landmarks = nil
}

// SetConnectivity sets the "connectivity" field.
func (m *LocationMutation) SetConnectivity(sc schema.LocationConnectivity) {
	m.connectivity = &sc
}

// Connectivity returns the value of the "connectivity" field in the mutation.
func (m *LocationMutation) Connectivity() (r schema.LocationConnectivity, exists bool) {
	v := m.connectivity
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectivity returns the old "connectivity" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldConnectivity(ctx context.Context) (v schema.LocationConnectivity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectivity: %w", err)
	}
	return oldValue.Connectivity, nil
}

// ResetConnectivity resets all changes to the "connectivity" field.
func (m *LocationMutation) ResetConnectivity() {
	m.connectivity = nil
}

// SetIsActive sets the "is_active" field.
func (m *LocationMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *LocationMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *LocationMutation) ResetIsActive() {
	m.is_active = nil
}

// SetSlug sets the "slug" field.
func (m *LocationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *LocationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *LocationMutation) ResetSlug() {
	m.slug = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *LocationMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *LocationMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *LocationMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *LocationMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *LocationMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *LocationMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *LocationMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.locality_name != nil {
		fields = append(fields, location.FieldLocalityName)
	}
	if m.city != nil {
		fields = append(fields, location.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, location.FieldState)
	}
	if m.phone_number != nil {
		fields = append(fields, location.FieldPhoneNumber)
	}
	if m.country != nil {
		fields = append(fields, location.FieldCountry)
	}
	if m.pincode != nil {
		fields = append(fields, location.FieldPincode)
	}
	if m.area_type != nil {
		fields = append(fields, location.FieldAreaType)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.google_map_link != nil {
		fields = append(fields, location.FieldGoogleMapLink)
	}
	if m.location_description != nil {
		fields = append(fields, location.FieldLocationDescription)
	}
	if m.nearby_landmarks != nil {
		fields = append(fields, location.FieldNearbyLandmarks)
	}
	if m.connectivity != nil {
		fields = append(fields, location.FieldConnectivity)
	}
	if m.is_active != nil {
		fields = append(fields, location.FieldIsActive)
	}
	if m.slug != nil {
		fields = append(fields, location.FieldSlug)
	}
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLocalityName:
		return m.LocalityName()
	case location.FieldCity:
		return m.City()
	case location.FieldState:
		return m.State()
	case location.FieldPhoneNumber:
		return m.PhoneNumber()
	case location.FieldCountry:
		return m.Country()
	case location.FieldPincode:
		return m.Pincode()
	case location.FieldAreaType:
		return m.AreaType()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldGoogleMapLink:
		return m.GoogleMapLink()
	case location.FieldLocationDescription:
		return m.LocationDescription()
	case location.FieldNearbyLandmarks:
		return m.NearbyLandmarks()
	case location.FieldConnectivity:
		return m.Connectivity()
	case location.FieldIsActive:
		return m.IsActive()
	case location.FieldSlug:
		return m.Slug()
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldLocalityName:
		return m.OldLocalityName(ctx)
	case location.FieldCity:
		return m.OldCity(ctx)
	case location.FieldState:
		return m.OldState(ctx)
	case location.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case location.FieldCountry:
		return m.OldCountry(ctx)
	case location.FieldPincode:
		return m.OldPincode(ctx)
	case location.FieldAreaType:
		return m.OldAreaType(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldGoogleMapLink:
		return m.OldGoogleMapLink(ctx)
	case location.FieldLocationDescription:
		return m.OldLocationDescription(ctx)
	case location.FieldNearbyLandmarks:
		return m.OldNearbyLandmarks(ctx)
	case location.FieldConnectivity:
		return m.OldConnectivity(ctx)
	case location.FieldIsActive:
		return m.OldIsActive(ctx)
	case location.FieldSlug:
		return m.OldSlug(ctx)
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldLocalityName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalityName(v)
		return nil
	case location.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case location.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case location.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case location.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case location.FieldPincode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPincode(v)
		return nil
	case location.FieldAreaType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaType(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldGoogleMapLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleMapLink(v)
		return nil
	case location.FieldLocationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationDescription(v)
		return nil
	case location.FieldNearbyLandmarks:
		v, ok := value.(schema.NearbyLandmarks)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNearbyLandmarks(v)
		return nil
	case location.FieldConnectivity:
		v, ok := value.(schema.LocationConnectivity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectivity(v)
		return nil
	case location.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case location.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLatitude:
		return m.AddedLatitude()
	case location.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldLatitude) {
		fields = append(fields, location.FieldLatitude)
	}
	if m.FieldCleared(location.FieldLongitude) {
		fields = append(fields, location.FieldLongitude)
	}
	if m.FieldCleared(location.FieldGoogleMapLink) {
		fields = append(fields, location.FieldGoogleMapLink)
	}
	if m.FieldCleared(location.FieldLocationDescription) {
		fields = append(fields, location.FieldLocationDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldLatitude:
		m.ClearLatitude()
		return nil
	case location.FieldLongitude:
		m.ClearLongitude()
		return nil
	case location.FieldGoogleMapLink:
		m.ClearGoogleMapLink()
		return nil
	case location.FieldLocationDescription:
		m.ClearLocationDescription()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldLocalityName:
		m.ResetLocalityName()
		return nil
	case location.FieldCity:
		m.ResetCity()
		return nil
	case location.FieldState:
		m.ResetState()
		return nil
	case location.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case location.FieldCountry:
		m.ResetCountry()
		return nil
	case location.FieldPincode:
		m.ResetPincode()
		return nil
	case location.FieldAreaType:
		m.ResetAreaType()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldGoogleMapLink:
		m.ResetGoogleMapLink()
		return nil
	case location.FieldLocationDescription:
		m.ResetLocationDescription()
		return nil
	case location.FieldNearbyLandmarks:
		m.ResetNearbyLandmarks()
		return nil
	case location.FieldConnectivity:
		m.ResetConnectivity()
		return nil
	case location.FieldIsActive:
		m.ResetIsActive()
		return nil
	case location.FieldSlug:
		m.ResetSlug()
		return nil
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, location.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, location.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, location.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	basic_info           *schema.BasicInfo
	timeline_info        *schema.TimelineInfo
	seo_meta             *schema.SEOMeta
	website_cards        *schema.WebsiteCards
	is_featured          *bool
	is_premium           *bool
	is_priority          *bool
	is_deleted           *bool
	search_context       *[]string
	appendsearch_context []string
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	properties           map[int]struct{}
	removedproperties    map[int]struct{}
	clearedproperties    bool
	location             *int
	clearedlocation      bool
	developer            *int
	cleareddeveloper     bool
	done                 bool
	oldValue             func(context.Context) (*Project, error)
	predicates           []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBasicInfo sets the "basic_info" field.
func (m *ProjectMutation) SetBasicInfo(si schema.BasicInfo) {
	m.basic_info = &si
}

// BasicInfo returns the value of the "basic_info" field in the mutation.
func (m *ProjectMutation) BasicInfo() (r schema.BasicInfo, exists bool) {
	v := m.basic_info
	if v == nil {
		return
	}
	return *v, true
}

// OldBasicInfo returns the old "basic_info" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBasicInfo(ctx context.Context) (v schema.BasicInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasicInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasicInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasicInfo: %w", err)
	}
	return oldValue.BasicInfo, nil
}

// ResetBasicInfo resets all changes to the "basic_info" field.
func (m *ProjectMutation) ResetBasicInfo() {
	m.basic_info = nil
}

// SetTimelineInfo sets the "timeline_info" field.
func (m *ProjectMutation) SetTimelineInfo(si schema.TimelineInfo) {
	m.timeline_info = &si
}

// TimelineInfo returns the value of the "timeline_info" field in the mutation.
func (m *ProjectMutation) TimelineInfo() (r schema.TimelineInfo, exists bool) {
	v := m.timeline_info
	if v == nil {
		return
	}
	return *v, true
}

// OldTimelineInfo returns the old "timeline_info" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTimelineInfo(ctx context.Context) (v schema.TimelineInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimelineInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimelineInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimelineInfo: %w", err)
	}
	return oldValue.TimelineInfo, nil
}

// ResetTimelineInfo resets all changes to the "timeline_info" field.
func (m *ProjectMutation) ResetTimelineInfo() {
	m.timeline_info = nil
}

// SetSeoMeta sets the "seo_meta" field.
func (m *ProjectMutation) SetSeoMeta(sm schema.SEOMeta) {
	m.seo_meta = &sm
}

// SeoMeta returns the value of the "seo_meta" field in the mutation.
func (m *ProjectMutation) SeoMeta() (r schema.SEOMeta, exists bool) {
	v := m.seo_meta
	if v == nil {
		return
	}
	return *v, true
}

// OldSeoMeta returns the old "seo_meta" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSeoMeta(ctx context.Context) (v schema.SEOMeta, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeoMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeoMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeoMeta: %w", err)
	}
	return oldValue.SeoMeta, nil
}

// ResetSeoMeta resets all changes to the "seo_meta" field.
func (m *ProjectMutation) ResetSeoMeta() {
	m.seo_meta = nil
}

// SetWebsiteCards sets the "website_cards" field.
func (m *ProjectMutation) SetWebsiteCards(sc schema.WebsiteCards) {
	m.website_cards = &sc
}

// WebsiteCards returns the value of the "website_cards" field in the mutation.
func (m *ProjectMutation) WebsiteCards() (r schema.WebsiteCards, exists bool) {
	v := m.website_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteCards returns the old "website_cards" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldWebsiteCards(ctx context.Context) (v schema.WebsiteCards, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteCards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteCards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteCards: %w", err)
	}
	return oldValue.WebsiteCards, nil
}

// ResetWebsiteCards resets all changes to the "website_cards" field.
func (m *ProjectMutation) ResetWebsiteCards() {
	m.website_cards = nil
}

// SetIsFeatured sets the "is_featured" field.
func (m *ProjectMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *ProjectMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *ProjectMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// SetIsPremium sets the "is_premium" field.
func (m *ProjectMutation) SetIsPremium(b bool) {
	m.is_premium = &b
}

// IsPremium returns the value of the "is_premium" field in the mutation.
func (m *ProjectMutation) IsPremium() (r bool, exists bool) {
	v := m.is_premium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old "is_premium" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPremium is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium resets all changes to the "is_premium" field.
func (m *ProjectMutation) ResetIsPremium() {
	m.is_premium = nil
}

// SetIsPriority sets the "is_priority" field.
func (m *ProjectMutation) SetIsPriority(b bool) {
	m.is_priority = &b
}

// IsPriority returns the value of the "is_priority" field in the mutation.
func (m *ProjectMutation) IsPriority() (r bool, exists bool) {
	v := m.is_priority
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPriority returns the old "is_priority" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsPriority(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPriority: %w", err)
	}
	return oldValue.IsPriority, nil
}

// ResetIsPriority resets all changes to the "is_priority" field.
func (m *ProjectMutation) ResetIsPriority() {
	m.is_priority = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *ProjectMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *ProjectMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *ProjectMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetSearchContext sets the "search_context" field.
func (m *ProjectMutation) SetSearchContext(s []string) {
	m.search_context = &s
	m.appendsearch_context = nil
}

// SearchContext returns the value of the "search_context" field in the mutation.
func (m *ProjectMutation) SearchContext() (r []string, exists bool) {
	v := m.search_context
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchContext returns the old "search_context" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSearchContext(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchContext: %w", err)
	}
	return oldValue.SearchContext, nil
}

// AppendSearchContext adds s to the "search_context" field.
func (m *ProjectMutation) AppendSearchContext(s []string) {
	m.appendsearch_context = append(m.appendsearch_context, s...)
}

// AppendedSearchContext returns the list of values that were appended to the "search_context" field in this mutation.
func (m *ProjectMutation) AppendedSearchContext() ([]string, bool) {
	if len(m.appendsearch_context) == 0 {
		return nil, false
	}
	return m.appendsearch_context, true
}

// ResetSearchContext resets all changes to the "search_context" field.
func (m *ProjectMutation) ResetSearchContext() {
	m.search_context = nil
	m.appendsearch_context = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *ProjectMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *ProjectMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *ProjectMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *ProjectMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *ProjectMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *ProjectMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *ProjectMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetLocationID sets the "location" edge to the Location entity by id.
func (m *ProjectMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *ProjectMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *ProjectMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *ProjectMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *ProjectMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetDeveloperID sets the "developer" edge to the Developer entity by id.
func (m *ProjectMutation) SetDeveloperID(id int) {
	m.developer = &id
}

// ClearDeveloper clears the "developer" edge to the Developer entity.
func (m *ProjectMutation) ClearDeveloper() {
	m.cleareddeveloper = true
}

// DeveloperCleared reports if the "developer" edge to the Developer entity was cleared.
func (m *ProjectMutation) DeveloperCleared() bool {
	return m.cleareddeveloper
}

// DeveloperID returns the "developer" edge ID in the mutation.
func (m *ProjectMutation) DeveloperID() (id int, exists bool) {
	if m.developer != nil {
		return *m.developer, true
	}
	return
}

// DeveloperIDs returns the "developer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeveloperID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) DeveloperIDs() (ids []int) {
	if id := m.developer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeveloper resets all changes to the "developer" edge.
func (m *ProjectMutation) ResetDeveloper() {
	m.developer = nil
	m.cleareddeveloper = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.basic_info != nil {
		fields = append(fields, project.FieldBasicInfo)
	}
	if m.timeline_info != nil {
		fields = append(fields, project.FieldTimelineInfo)
	}
	if m.seo_meta != nil {
		fields = append(fields, project.FieldSeoMeta)
	}
	if m.website_cards != nil {
		fields = append(fields, project.FieldWebsiteCards)
	}
	if m.is_featured != nil {
		fields = append(fields, project.FieldIsFeatured)
	}
	if m.is_premium != nil {
		fields = append(fields, project.FieldIsPremium)
	}
	if m.is_priority != nil {
		fields = append(fields, project.FieldIsPriority)
	}
	if m.is_deleted != nil {
		fields = append(fields, project.FieldIsDeleted)
	}
	if m.search_context != nil {
		fields = append(fields, project.FieldSearchContext)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldBasicInfo:
		return m.BasicInfo()
	case project.FieldTimelineInfo:
		return m.TimelineInfo()
	case project.FieldSeoMeta:
		return m.SeoMeta()
	case project.FieldWebsiteCards:
		return m.WebsiteCards()
	case project.FieldIsFeatured:
		return m.IsFeatured()
	case project.FieldIsPremium:
		return m.IsPremium()
	case project.FieldIsPriority:
		return m.IsPriority()
	case project.FieldIsDeleted:
		return m.IsDeleted()
	case project.FieldSearchContext:
		return m.SearchContext()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldBasicInfo:
		return m.OldBasicInfo(ctx)
	case project.FieldTimelineInfo:
		return m.OldTimelineInfo(ctx)
	case project.FieldSeoMeta:
		return m.OldSeoMeta(ctx)
	case project.FieldWebsiteCards:
		return m.OldWebsiteCards(ctx)
	case project.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case project.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case project.FieldIsPriority:
		return m.OldIsPriority(ctx)
	case project.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case project.FieldSearchContext:
		return m.OldSearchContext(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldBasicInfo:
		v, ok := value.(schema.BasicInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasicInfo(v)
		return nil
	case project.FieldTimelineInfo:
		v, ok := value.(schema.TimelineInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimelineInfo(v)
		return nil
	case project.FieldSeoMeta:
		v, ok := value.(schema.SEOMeta)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeoMeta(v)
		return nil
	case project.FieldWebsiteCards:
		v, ok := value.(schema.WebsiteCards)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteCards(v)
		return nil
	case project.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case project.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case project.FieldIsPriority:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPriority(v)
		return nil
	case project.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case project.FieldSearchContext:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchContext(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldBasicInfo:
		m.ResetBasicInfo()
		return nil
	case project.FieldTimelineInfo:
		m.ResetTimelineInfo()
		return nil
	case project.FieldSeoMeta:
		m.ResetSeoMeta()
		return nil
	case project.FieldWebsiteCards:
		m.ResetWebsiteCards()
		return nil
	case project.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case project.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case project.FieldIsPriority:
		m.ResetIsPriority()
		return nil
	case project.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case project.FieldSearchContext:
		m.ResetSearchContext()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.properties != nil {
		edges = append(edges, project.EdgeProperties)
	}
	if m.location != nil {
		edges = append(edges, project.EdgeLocation)
	}
	if m.developer != nil {
		edges = append(edges, project.EdgeDeveloper)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeDeveloper:
		if id := m.developer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, project.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperties {
		edges = append(edges, project.EdgeProperties)
	}
	if m.clearedlocation {
		edges = append(edges, project.EdgeLocation)
	}
	if m.cleareddeveloper {
		edges = append(edges, project.EdgeDeveloper)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeProperties:
		return m.clearedproperties
	case project.EdgeLocation:
		return m.clearedlocation
	case project.EdgeDeveloper:
		return m.cleareddeveloper
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeLocation:
		m.ClearLocation()
		return nil
	case project.EdgeDeveloper:
		m.ClearDeveloper()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeProperties:
		m.ResetProperties()
		return nil
	case project.EdgeLocation:
		m.ResetLocation()
		return nil
	case project.EdgeDeveloper:
		m.ResetDeveloper()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	name                        *string
	description                 *string
	basic_info                  *schema.PropertyBasicInfo
	area_details                *schema.PropertyAreaDetails
	location_details            *schema.PropertyLocationDetails
	pricing_info                *schema.PropertyPricingInfo
	features                    *schema.PropertyFeatures
	status_info                 *schema.PropertyStatusInfo
	property_images             *schema.PropertyImages
	property_details            *schema.PropertyDetails
	property_amenities          *schema.PropertyAmenities
	property_video_presentation *schema.PropertyVideoPresentation
	property_know_about         *schema.PropertyKnowAbout
	property_specifications     *schema.PropertySpecifications
	pricing_details             *schema.PropertyPricingDetails
	clearedFields               map[string]struct{}
	project                     *int
	clearedproject              bool
	leads                       map[int]struct{}
	removedleads                map[int]struct{}
	clearedleads                bool
	done                        bool
	oldValue                    func(context.Context) (*Property, error)
	predicates                  []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id int) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PropertyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PropertyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PropertyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PropertyMutation) ResetDescription() {
	m.description = nil
}

// SetBasicInfo sets the "basic_info" field.
func (m *PropertyMutation) SetBasicInfo(sbi schema.PropertyBasicInfo) {
	m.basic_info = &sbi
}

// BasicInfo returns the value of the "basic_info" field in the mutation.
func (m *PropertyMutation) BasicInfo() (r schema.PropertyBasicInfo, exists bool) {
	v := m.basic_info
	if v == nil {
		return
	}
	return *v, true
}

// OldBasicInfo returns the old "basic_info" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldBasicInfo(ctx context.Context) (v schema.PropertyBasicInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasicInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasicInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasicInfo: %w", err)
	}
	return oldValue.BasicInfo, nil
}

// ResetBasicInfo resets all changes to the "basic_info" field.
func (m *PropertyMutation) ResetBasicInfo() {
	m.basic_info = nil
}

// SetAreaDetails sets the "area_details" field.
func (m *PropertyMutation) SetAreaDetails(sad schema.PropertyAreaDetails) {
	m.area_details = &sad
}

// AreaDetails returns the value of the "area_details" field in the mutation.
func (m *PropertyMutation) AreaDetails() (r schema.PropertyAreaDetails, exists bool) {
	v := m.area_details
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaDetails returns the old "area_details" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldAreaDetails(ctx context.Context) (v schema.PropertyAreaDetails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaDetails: %w", err)
	}
	return oldValue.AreaDetails, nil
}

// ResetAreaDetails resets all changes to the "area_details" field.
func (m *PropertyMutation) ResetAreaDetails() {
	m.area_details = nil
}

// SetLocationDetails sets the "location_details" field.
func (m *PropertyMutation) SetLocationDetails(sld schema.PropertyLocationDetails) {
	m.location_details = &sld
}

// LocationDetails returns the value of the "location_details" field in the mutation.
func (m *PropertyMutation) LocationDetails() (r schema.PropertyLocationDetails, exists bool) {
	v := m.location_details
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationDetails returns the old "location_details" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldLocationDetails(ctx context.Context) (v schema.PropertyLocationDetails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationDetails: %w", err)
	}
	return oldValue.LocationDetails, nil
}

// ResetLocationDetails resets all changes to the "location_details" field.
func (m *PropertyMutation) ResetLocationDetails() {
	m.location_details = nil
}

// SetPricingInfo sets the "pricing_info" field.
func (m *PropertyMutation) SetPricingInfo(spi schema.PropertyPricingInfo) {
	m.pricing_info = &spi
}

// PricingInfo returns the value of the "pricing_info" field in the mutation.
func (m *PropertyMutation) PricingInfo() (r schema.PropertyPricingInfo, exists bool) {
	v := m.pricing_info
	if v == nil {
		return
	}
	return *v, true
}

// OldPricingInfo returns the old "pricing_info" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPricingInfo(ctx context.Context) (v schema.PropertyPricingInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricingInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricingInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricingInfo: %w", err)
	}
	return oldValue.PricingInfo, nil
}

// ResetPricingInfo resets all changes to the "pricing_info" field.
func (m *PropertyMutation) ResetPricingInfo() {
	m.pricing_info = nil
}

// SetFeatures sets the "features" field.
func (m *PropertyMutation) SetFeatures(sf schema.PropertyFeatures) {
	m.features = &sf
}

// Features returns the value of the "features" field in the mutation.
func (m *PropertyMutation) Features() (r schema.PropertyFeatures, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldFeatures(ctx context.Context) (v schema.PropertyFeatures, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// ResetFeatures resets all changes to the "features" field.
func (m *PropertyMutation) ResetFeatures() {
	m.features = nil
}

// SetStatusInfo sets the "status_info" field.
func (m *PropertyMutation) SetStatusInfo(ssi schema.PropertyStatusInfo) {
	m.status_info = &ssi
}

// StatusInfo returns the value of the "status_info" field in the mutation.
func (m *PropertyMutation) StatusInfo() (r schema.PropertyStatusInfo, exists bool) {
	v := m.status_info
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusInfo returns the old "status_info" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldStatusInfo(ctx context.Context) (v schema.PropertyStatusInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusInfo: %w", err)
	}
	return oldValue.StatusInfo, nil
}

// ResetStatusInfo resets all changes to the "status_info" field.
func (m *PropertyMutation) ResetStatusInfo() {
	m.status_info = nil
}

// SetPropertyImages sets the "property_images" field.
func (m *PropertyMutation) SetPropertyImages(si schema.PropertyImages) {
	m.property_images = &si
}

// PropertyImages returns the value of the "property_images" field in the mutation.
func (m *PropertyMutation) PropertyImages() (r schema.PropertyImages, exists bool) {
	v := m.property_images
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyImages returns the old "property_images" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertyImages(ctx context.Context) (v schema.PropertyImages, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyImages: %w", err)
	}
	return oldValue.PropertyImages, nil
}

// ResetPropertyImages resets all changes to the "property_images" field.
func (m *PropertyMutation) ResetPropertyImages() {
	m.property_images = nil
}

// SetPropertyDetails sets the "property_details" field.
func (m *PropertyMutation) SetPropertyDetails(sd schema.PropertyDetails) {
	m.property_details = &sd
}

// PropertyDetails returns the value of the "property_details" field in the mutation.
func (m *PropertyMutation) PropertyDetails() (r schema.PropertyDetails, exists bool) {
	v := m.property_details
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyDetails returns the old "property_details" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertyDetails(ctx context.Context) (v schema.PropertyDetails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyDetails: %w", err)
	}
	return oldValue.PropertyDetails, nil
}

// ResetPropertyDetails resets all changes to the "property_details" field.
func (m *PropertyMutation) ResetPropertyDetails() {
	m.property_details = nil
}

// SetPropertyAmenities sets the "property_amenities" field.
func (m *PropertyMutation) SetPropertyAmenities(sa schema.PropertyAmenities) {
	m.property_amenities = &sa
}

// PropertyAmenities returns the value of the "property_amenities" field in the mutation.
func (m *PropertyMutation) PropertyAmenities() (r schema.PropertyAmenities, exists bool) {
	v := m.property_amenities
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyAmenities returns the old "property_amenities" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertyAmenities(ctx context.Context) (v schema.PropertyAmenities, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyAmenities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyAmenities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyAmenities: %w", err)
	}
	return oldValue.PropertyAmenities, nil
}

// ResetPropertyAmenities resets all changes to the "property_amenities" field.
func (m *PropertyMutation) ResetPropertyAmenities() {
	m.property_amenities = nil
}

// SetPropertyVideoPresentation sets the "property_video_presentation" field.
func (m *PropertyMutation) SetPropertyVideoPresentation(svp schema.PropertyVideoPresentation) {
	m.property_video_presentation = &svp
}

// PropertyVideoPresentation returns the value of the "property_video_presentation" field in the mutation.
func (m *PropertyMutation) PropertyVideoPresentation() (r schema.PropertyVideoPresentation, exists bool) {
	v := m.property_video_presentation
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyVideoPresentation returns the old "property_video_presentation" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertyVideoPresentation(ctx context.Context) (v schema.PropertyVideoPresentation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyVideoPresentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyVideoPresentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyVideoPresentation: %w", err)
	}
	return oldValue.PropertyVideoPresentation, nil
}

// ResetPropertyVideoPresentation resets all changes to the "property_video_presentation" field.
func (m *PropertyMutation) ResetPropertyVideoPresentation() {
	m.property_video_presentation = nil
}

// SetPropertyKnowAbout sets the "property_know_about" field.
func (m *PropertyMutation) SetPropertyKnowAbout(ska schema.PropertyKnowAbout) {
	m.property_know_about = &ska
}

// PropertyKnowAbout returns the value of the "property_know_about" field in the mutation.
func (m *PropertyMutation) PropertyKnowAbout() (r schema.PropertyKnowAbout, exists bool) {
	v := m.property_know_about
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyKnowAbout returns the old "property_know_about" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertyKnowAbout(ctx context.Context) (v schema.PropertyKnowAbout, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyKnowAbout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyKnowAbout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyKnowAbout: %w", err)
	}
	return oldValue.PropertyKnowAbout, nil
}

// ResetPropertyKnowAbout resets all changes to the "property_know_about" field.
func (m *PropertyMutation) ResetPropertyKnowAbout() {
	m.property_know_about = nil
}

// SetPropertySpecifications sets the "property_specifications" field.
func (m *PropertyMutation) SetPropertySpecifications(ss schema.PropertySpecifications) {
	m.property_specifications = &ss
}

// PropertySpecifications returns the value of the "property_specifications" field in the mutation.
func (m *PropertyMutation) PropertySpecifications() (r schema.PropertySpecifications, exists bool) {
	v := m.property_specifications
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertySpecifications returns the old "property_specifications" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPropertySpecifications(ctx context.Context) (v schema.PropertySpecifications, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertySpecifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertySpecifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertySpecifications: %w", err)
	}
	return oldValue.PropertySpecifications, nil
}

// ResetPropertySpecifications resets all changes to the "property_specifications" field.
func (m *PropertyMutation) ResetPropertySpecifications() {
	m.property_specifications = nil
}

// SetPricingDetails sets the "pricing_details" field.
func (m *PropertyMutation) SetPricingDetails(spd schema.PropertyPricingDetails) {
	m.pricing_details = &spd
}

// PricingDetails returns the value of the "pricing_details" field in the mutation.
func (m *PropertyMutation) PricingDetails() (r schema.PropertyPricingDetails, exists bool) {
	v := m.pricing_details
	if v == nil {
		return
	}
	return *v, true
}

// OldPricingDetails returns the old "pricing_details" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldPricingDetails(ctx context.Context) (v schema.PropertyPricingDetails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricingDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricingDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricingDetails: %w", err)
	}
	return oldValue.PricingDetails, nil
}

// ClearPricingDetails clears the value of the "pricing_details" field.
func (m *PropertyMutation) ClearPricingDetails() {
	m.pricing_details = nil
	m.clearedFields[property.FieldPricingDetails] = struct{}{}
}

// PricingDetailsCleared returns if the "pricing_details" field was cleared in this mutation.
func (m *PropertyMutation) PricingDetailsCleared() bool {
	_, ok := m.clearedFields[property.FieldPricingDetails]
	return ok
}

// ResetPricingDetails resets all changes to the "pricing_details" field.
func (m *PropertyMutation) ResetPricingDetails() {
	m.pricing_details = nil
	delete(m.clearedFields, property.FieldPricingDetails)
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *PropertyMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *PropertyMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *PropertyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *PropertyMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *PropertyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddLeadIDs adds the "leads" edge to the Leads entity by ids.
func (m *PropertyMutation) AddLeadIDs(ids ...int) {
	if m.leads == nil {
		m.leads = make(map[int]struct{})
	}
	for i := range ids {
		m.leads[ids[i]] = struct{}{}
	}
}

// ClearLeads clears the "leads" edge to the Leads entity.
func (m *PropertyMutation) ClearLeads() {
	m.clearedleads = true
}

// LeadsCleared reports if the "leads" edge to the Leads entity was cleared.
func (m *PropertyMutation) LeadsCleared() bool {
	return m.clearedleads
}

// RemoveLeadIDs removes the "leads" edge to the Leads entity by IDs.
func (m *PropertyMutation) RemoveLeadIDs(ids ...int) {
	if m.removedleads == nil {
		m.removedleads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leads, ids[i])
		m.removedleads[ids[i]] = struct{}{}
	}
}

// RemovedLeads returns the removed IDs of the "leads" edge to the Leads entity.
func (m *PropertyMutation) RemovedLeadsIDs() (ids []int) {
	for id := range m.removedleads {
		ids = append(ids, id)
	}
	return
}

// LeadsIDs returns the "leads" edge IDs in the mutation.
func (m *PropertyMutation) LeadsIDs() (ids []int) {
	for id := range m.leads {
		ids = append(ids, id)
	}
	return
}

// ResetLeads resets all changes to the "leads" edge.
func (m *PropertyMutation) ResetLeads() {
	m.leads = nil
	m.clearedleads = false
	m.removedleads = nil
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, property.FieldName)
	}
	if m.description != nil {
		fields = append(fields, property.FieldDescription)
	}
	if m.basic_info != nil {
		fields = append(fields, property.FieldBasicInfo)
	}
	if m.area_details != nil {
		fields = append(fields, property.FieldAreaDetails)
	}
	if m.location_details != nil {
		fields = append(fields, property.FieldLocationDetails)
	}
	if m.pricing_info != nil {
		fields = append(fields, property.FieldPricingInfo)
	}
	if m.features != nil {
		fields = append(fields, property.FieldFeatures)
	}
	if m.status_info != nil {
		fields = append(fields, property.FieldStatusInfo)
	}
	if m.property_images != nil {
		fields = append(fields, property.FieldPropertyImages)
	}
	if m.property_details != nil {
		fields = append(fields, property.FieldPropertyDetails)
	}
	if m.property_amenities != nil {
		fields = append(fields, property.FieldPropertyAmenities)
	}
	if m.property_video_presentation != nil {
		fields = append(fields, property.FieldPropertyVideoPresentation)
	}
	if m.property_know_about != nil {
		fields = append(fields, property.FieldPropertyKnowAbout)
	}
	if m.property_specifications != nil {
		fields = append(fields, property.FieldPropertySpecifications)
	}
	if m.pricing_details != nil {
		fields = append(fields, property.FieldPricingDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldName:
		return m.Name()
	case property.FieldDescription:
		return m.Description()
	case property.FieldBasicInfo:
		return m.BasicInfo()
	case property.FieldAreaDetails:
		return m.AreaDetails()
	case property.FieldLocationDetails:
		return m.LocationDetails()
	case property.FieldPricingInfo:
		return m.PricingInfo()
	case property.FieldFeatures:
		return m.Features()
	case property.FieldStatusInfo:
		return m.StatusInfo()
	case property.FieldPropertyImages:
		return m.PropertyImages()
	case property.FieldPropertyDetails:
		return m.PropertyDetails()
	case property.FieldPropertyAmenities:
		return m.PropertyAmenities()
	case property.FieldPropertyVideoPresentation:
		return m.PropertyVideoPresentation()
	case property.FieldPropertyKnowAbout:
		return m.PropertyKnowAbout()
	case property.FieldPropertySpecifications:
		return m.PropertySpecifications()
	case property.FieldPricingDetails:
		return m.PricingDetails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldName:
		return m.OldName(ctx)
	case property.FieldDescription:
		return m.OldDescription(ctx)
	case property.FieldBasicInfo:
		return m.OldBasicInfo(ctx)
	case property.FieldAreaDetails:
		return m.OldAreaDetails(ctx)
	case property.FieldLocationDetails:
		return m.OldLocationDetails(ctx)
	case property.FieldPricingInfo:
		return m.OldPricingInfo(ctx)
	case property.FieldFeatures:
		return m.OldFeatures(ctx)
	case property.FieldStatusInfo:
		return m.OldStatusInfo(ctx)
	case property.FieldPropertyImages:
		return m.OldPropertyImages(ctx)
	case property.FieldPropertyDetails:
		return m.OldPropertyDetails(ctx)
	case property.FieldPropertyAmenities:
		return m.OldPropertyAmenities(ctx)
	case property.FieldPropertyVideoPresentation:
		return m.OldPropertyVideoPresentation(ctx)
	case property.FieldPropertyKnowAbout:
		return m.OldPropertyKnowAbout(ctx)
	case property.FieldPropertySpecifications:
		return m.OldPropertySpecifications(ctx)
	case property.FieldPricingDetails:
		return m.OldPricingDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case property.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case property.FieldBasicInfo:
		v, ok := value.(schema.PropertyBasicInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasicInfo(v)
		return nil
	case property.FieldAreaDetails:
		v, ok := value.(schema.PropertyAreaDetails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaDetails(v)
		return nil
	case property.FieldLocationDetails:
		v, ok := value.(schema.PropertyLocationDetails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationDetails(v)
		return nil
	case property.FieldPricingInfo:
		v, ok := value.(schema.PropertyPricingInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricingInfo(v)
		return nil
	case property.FieldFeatures:
		v, ok := value.(schema.PropertyFeatures)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case property.FieldStatusInfo:
		v, ok := value.(schema.PropertyStatusInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusInfo(v)
		return nil
	case property.FieldPropertyImages:
		v, ok := value.(schema.PropertyImages)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyImages(v)
		return nil
	case property.FieldPropertyDetails:
		v, ok := value.(schema.PropertyDetails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyDetails(v)
		return nil
	case property.FieldPropertyAmenities:
		v, ok := value.(schema.PropertyAmenities)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyAmenities(v)
		return nil
	case property.FieldPropertyVideoPresentation:
		v, ok := value.(schema.PropertyVideoPresentation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyVideoPresentation(v)
		return nil
	case property.FieldPropertyKnowAbout:
		v, ok := value.(schema.PropertyKnowAbout)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyKnowAbout(v)
		return nil
	case property.FieldPropertySpecifications:
		v, ok := value.(schema.PropertySpecifications)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertySpecifications(v)
		return nil
	case property.FieldPricingDetails:
		v, ok := value.(schema.PropertyPricingDetails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricingDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldPricingDetails) {
		fields = append(fields, property.FieldPricingDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldPricingDetails:
		m.ClearPricingDetails()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldName:
		m.ResetName()
		return nil
	case property.FieldDescription:
		m.ResetDescription()
		return nil
	case property.FieldBasicInfo:
		m.ResetBasicInfo()
		return nil
	case property.FieldAreaDetails:
		m.ResetAreaDetails()
		return nil
	case property.FieldLocationDetails:
		m.ResetLocationDetails()
		return nil
	case property.FieldPricingInfo:
		m.ResetPricingInfo()
		return nil
	case property.FieldFeatures:
		m.ResetFeatures()
		return nil
	case property.FieldStatusInfo:
		m.ResetStatusInfo()
		return nil
	case property.FieldPropertyImages:
		m.ResetPropertyImages()
		return nil
	case property.FieldPropertyDetails:
		m.ResetPropertyDetails()
		return nil
	case property.FieldPropertyAmenities:
		m.ResetPropertyAmenities()
		return nil
	case property.FieldPropertyVideoPresentation:
		m.ResetPropertyVideoPresentation()
		return nil
	case property.FieldPropertyKnowAbout:
		m.ResetPropertyKnowAbout()
		return nil
	case property.FieldPropertySpecifications:
		m.ResetPropertySpecifications()
		return nil
	case property.FieldPricingDetails:
		m.ResetPricingDetails()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, property.EdgeProject)
	}
	if m.leads != nil {
		edges = append(edges, property.EdgeLeads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeLeads:
		ids := make([]ent.Value, 0, len(m.leads))
		for id := range m.leads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedleads != nil {
		edges = append(edges, property.EdgeLeads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeLeads:
		ids := make([]ent.Value, 0, len(m.removedleads))
		for id := range m.removedleads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, property.EdgeProject)
	}
	if m.clearedleads {
		edges = append(edges, property.EdgeLeads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeProject:
		return m.clearedproject
	case property.EdgeLeads:
		return m.clearedleads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeProject:
		m.ResetProject()
		return nil
	case property.EdgeLeads:
		m.ResetLeads()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// StaticSiteDataMutation represents an operation that mutates the StaticSiteData nodes in the graph.
type StaticSiteDataMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	about_us               *[]uint8
	appendabout_us         []uint8
	how_we_work            *[]uint8
	appendhow_we_work      []uint8
	testimonials           *[]uint8
	appendtestimonials     []uint8
	mango_insights         *[]uint8
	appendmango_insights   []uint8
	our_associations       *[]uint8
	appendour_associations []uint8
	updated_at             *time.Time
	created_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*StaticSiteData, error)
	predicates             []predicate.StaticSiteData
}

var _ ent.Mutation = (*StaticSiteDataMutation)(nil)

// staticsitedataOption allows management of the mutation configuration using functional options.
type staticsitedataOption func(*StaticSiteDataMutation)

// newStaticSiteDataMutation creates new mutation for the StaticSiteData entity.
func newStaticSiteDataMutation(c config, op Op, opts ...staticsitedataOption) *StaticSiteDataMutation {
	m := &StaticSiteDataMutation{
		config:        c,
		op:            op,
		typ:           TypeStaticSiteData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaticSiteDataID sets the ID field of the mutation.
func withStaticSiteDataID(id int) staticsitedataOption {
	return func(m *StaticSiteDataMutation) {
		var (
			err   error
			once  sync.Once
			value *StaticSiteData
		)
		m.oldValue = func(ctx context.Context) (*StaticSiteData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StaticSiteData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaticSiteData sets the old StaticSiteData of the mutation.
func withStaticSiteData(node *StaticSiteData) staticsitedataOption {
	return func(m *StaticSiteDataMutation) {
		m.oldValue = func(context.Context) (*StaticSiteData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaticSiteDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaticSiteDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StaticSiteData entities.
func (m *StaticSiteDataMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaticSiteDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaticSiteDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StaticSiteData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAboutUs sets the "about_us" field.
func (m *StaticSiteDataMutation) SetAboutUs(u []uint8) {
	m.about_us = &u
	m.appendabout_us = nil
}

// AboutUs returns the value of the "about_us" field in the mutation.
func (m *StaticSiteDataMutation) AboutUs() (r []uint8, exists bool) {
	v := m.about_us
	if v == nil {
		return
	}
	return *v, true
}

// OldAboutUs returns the old "about_us" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldAboutUs(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAboutUs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAboutUs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAboutUs: %w", err)
	}
	return oldValue.AboutUs, nil
}

// AppendAboutUs adds u to the "about_us" field.
func (m *StaticSiteDataMutation) AppendAboutUs(u []uint8) {
	m.appendabout_us = append(m.appendabout_us, u...)
}

// AppendedAboutUs returns the list of values that were appended to the "about_us" field in this mutation.
func (m *StaticSiteDataMutation) AppendedAboutUs() ([]uint8, bool) {
	if len(m.appendabout_us) == 0 {
		return nil, false
	}
	return m.appendabout_us, true
}

// ResetAboutUs resets all changes to the "about_us" field.
func (m *StaticSiteDataMutation) ResetAboutUs() {
	m.about_us = nil
	m.appendabout_us = nil
}

// SetHowWeWork sets the "how_we_work" field.
func (m *StaticSiteDataMutation) SetHowWeWork(u []uint8) {
	m.how_we_work = &u
	m.appendhow_we_work = nil
}

// HowWeWork returns the value of the "how_we_work" field in the mutation.
func (m *StaticSiteDataMutation) HowWeWork() (r []uint8, exists bool) {
	v := m.how_we_work
	if v == nil {
		return
	}
	return *v, true
}

// OldHowWeWork returns the old "how_we_work" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldHowWeWork(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHowWeWork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHowWeWork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHowWeWork: %w", err)
	}
	return oldValue.HowWeWork, nil
}

// AppendHowWeWork adds u to the "how_we_work" field.
func (m *StaticSiteDataMutation) AppendHowWeWork(u []uint8) {
	m.appendhow_we_work = append(m.appendhow_we_work, u...)
}

// AppendedHowWeWork returns the list of values that were appended to the "how_we_work" field in this mutation.
func (m *StaticSiteDataMutation) AppendedHowWeWork() ([]uint8, bool) {
	if len(m.appendhow_we_work) == 0 {
		return nil, false
	}
	return m.appendhow_we_work, true
}

// ResetHowWeWork resets all changes to the "how_we_work" field.
func (m *StaticSiteDataMutation) ResetHowWeWork() {
	m.how_we_work = nil
	m.appendhow_we_work = nil
}

// SetTestimonials sets the "testimonials" field.
func (m *StaticSiteDataMutation) SetTestimonials(u []uint8) {
	m.testimonials = &u
	m.appendtestimonials = nil
}

// Testimonials returns the value of the "testimonials" field in the mutation.
func (m *StaticSiteDataMutation) Testimonials() (r []uint8, exists bool) {
	v := m.testimonials
	if v == nil {
		return
	}
	return *v, true
}

// OldTestimonials returns the old "testimonials" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldTestimonials(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestimonials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestimonials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestimonials: %w", err)
	}
	return oldValue.Testimonials, nil
}

// AppendTestimonials adds u to the "testimonials" field.
func (m *StaticSiteDataMutation) AppendTestimonials(u []uint8) {
	m.appendtestimonials = append(m.appendtestimonials, u...)
}

// AppendedTestimonials returns the list of values that were appended to the "testimonials" field in this mutation.
func (m *StaticSiteDataMutation) AppendedTestimonials() ([]uint8, bool) {
	if len(m.appendtestimonials) == 0 {
		return nil, false
	}
	return m.appendtestimonials, true
}

// ResetTestimonials resets all changes to the "testimonials" field.
func (m *StaticSiteDataMutation) ResetTestimonials() {
	m.testimonials = nil
	m.appendtestimonials = nil
}

// SetMangoInsights sets the "mango_insights" field.
func (m *StaticSiteDataMutation) SetMangoInsights(u []uint8) {
	m.mango_insights = &u
	m.appendmango_insights = nil
}

// MangoInsights returns the value of the "mango_insights" field in the mutation.
func (m *StaticSiteDataMutation) MangoInsights() (r []uint8, exists bool) {
	v := m.mango_insights
	if v == nil {
		return
	}
	return *v, true
}

// OldMangoInsights returns the old "mango_insights" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldMangoInsights(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMangoInsights is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMangoInsights requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMangoInsights: %w", err)
	}
	return oldValue.MangoInsights, nil
}

// AppendMangoInsights adds u to the "mango_insights" field.
func (m *StaticSiteDataMutation) AppendMangoInsights(u []uint8) {
	m.appendmango_insights = append(m.appendmango_insights, u...)
}

// AppendedMangoInsights returns the list of values that were appended to the "mango_insights" field in this mutation.
func (m *StaticSiteDataMutation) AppendedMangoInsights() ([]uint8, bool) {
	if len(m.appendmango_insights) == 0 {
		return nil, false
	}
	return m.appendmango_insights, true
}

// ResetMangoInsights resets all changes to the "mango_insights" field.
func (m *StaticSiteDataMutation) ResetMangoInsights() {
	m.mango_insights = nil
	m.appendmango_insights = nil
}

// SetOurAssociations sets the "our_associations" field.
func (m *StaticSiteDataMutation) SetOurAssociations(u []uint8) {
	m.our_associations = &u
	m.appendour_associations = nil
}

// OurAssociations returns the value of the "our_associations" field in the mutation.
func (m *StaticSiteDataMutation) OurAssociations() (r []uint8, exists bool) {
	v := m.our_associations
	if v == nil {
		return
	}
	return *v, true
}

// OldOurAssociations returns the old "our_associations" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldOurAssociations(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOurAssociations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOurAssociations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOurAssociations: %w", err)
	}
	return oldValue.OurAssociations, nil
}

// AppendOurAssociations adds u to the "our_associations" field.
func (m *StaticSiteDataMutation) AppendOurAssociations(u []uint8) {
	m.appendour_associations = append(m.appendour_associations, u...)
}

// AppendedOurAssociations returns the list of values that were appended to the "our_associations" field in this mutation.
func (m *StaticSiteDataMutation) AppendedOurAssociations() ([]uint8, bool) {
	if len(m.appendour_associations) == 0 {
		return nil, false
	}
	return m.appendour_associations, true
}

// ResetOurAssociations resets all changes to the "our_associations" field.
func (m *StaticSiteDataMutation) ResetOurAssociations() {
	m.our_associations = nil
	m.appendour_associations = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StaticSiteDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StaticSiteDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StaticSiteDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StaticSiteDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StaticSiteDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StaticSiteData entity.
// If the StaticSiteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaticSiteDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StaticSiteDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the StaticSiteDataMutation builder.
func (m *StaticSiteDataMutation) Where(ps ...predicate.StaticSiteData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaticSiteDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaticSiteDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StaticSiteData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaticSiteDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaticSiteDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StaticSiteData).
func (m *StaticSiteDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaticSiteDataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.about_us != nil {
		fields = append(fields, staticsitedata.FieldAboutUs)
	}
	if m.how_we_work != nil {
		fields = append(fields, staticsitedata.FieldHowWeWork)
	}
	if m.testimonials != nil {
		fields = append(fields, staticsitedata.FieldTestimonials)
	}
	if m.mango_insights != nil {
		fields = append(fields, staticsitedata.FieldMangoInsights)
	}
	if m.our_associations != nil {
		fields = append(fields, staticsitedata.FieldOurAssociations)
	}
	if m.updated_at != nil {
		fields = append(fields, staticsitedata.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, staticsitedata.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaticSiteDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staticsitedata.FieldAboutUs:
		return m.AboutUs()
	case staticsitedata.FieldHowWeWork:
		return m.HowWeWork()
	case staticsitedata.FieldTestimonials:
		return m.Testimonials()
	case staticsitedata.FieldMangoInsights:
		return m.MangoInsights()
	case staticsitedata.FieldOurAssociations:
		return m.OurAssociations()
	case staticsitedata.FieldUpdatedAt:
		return m.UpdatedAt()
	case staticsitedata.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaticSiteDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staticsitedata.FieldAboutUs:
		return m.OldAboutUs(ctx)
	case staticsitedata.FieldHowWeWork:
		return m.OldHowWeWork(ctx)
	case staticsitedata.FieldTestimonials:
		return m.OldTestimonials(ctx)
	case staticsitedata.FieldMangoInsights:
		return m.OldMangoInsights(ctx)
	case staticsitedata.FieldOurAssociations:
		return m.OldOurAssociations(ctx)
	case staticsitedata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case staticsitedata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StaticSiteData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaticSiteDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staticsitedata.FieldAboutUs:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAboutUs(v)
		return nil
	case staticsitedata.FieldHowWeWork:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHowWeWork(v)
		return nil
	case staticsitedata.FieldTestimonials:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestimonials(v)
		return nil
	case staticsitedata.FieldMangoInsights:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMangoInsights(v)
		return nil
	case staticsitedata.FieldOurAssociations:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOurAssociations(v)
		return nil
	case staticsitedata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case staticsitedata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StaticSiteData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaticSiteDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaticSiteDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaticSiteDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StaticSiteData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaticSiteDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaticSiteDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaticSiteDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StaticSiteData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaticSiteDataMutation) ResetField(name string) error {
	switch name {
	case staticsitedata.FieldAboutUs:
		m.ResetAboutUs()
		return nil
	case staticsitedata.FieldHowWeWork:
		m.ResetHowWeWork()
		return nil
	case staticsitedata.FieldTestimonials:
		m.ResetTestimonials()
		return nil
	case staticsitedata.FieldMangoInsights:
		m.ResetMangoInsights()
		return nil
	case staticsitedata.FieldOurAssociations:
		m.ResetOurAssociations()
		return nil
	case staticsitedata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case staticsitedata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StaticSiteData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaticSiteDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaticSiteDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaticSiteDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaticSiteDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaticSiteDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaticSiteDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaticSiteDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StaticSiteData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaticSiteDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StaticSiteData edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	username               *string
	password               *string
	email                  *string
	first_name             *string
	last_name              *string
	date_of_birth          *time.Time
	gender                 *string
	phone_number           *string
	current_address        *string
	permanent_address      *string
	is_active              *bool
	is_deleted             *bool
	is_email_verified      *bool
	is_verified            *bool
	last_login_time        *time.Time
	parent_id              *int
	addparent_id           *int
	photo_url              *string
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *int
	addcreated_by          *int
	updated_by             *int
	addupdated_by          *int
	clearedFields          map[string]struct{}
	updated_blogs          map[int]struct{}
	removedupdated_blogs   map[int]struct{}
	clearedupdated_blogs   bool
	created_by_user        *int
	clearedcreated_by_user bool
	created_users          map[int]struct{}
	removedcreated_users   map[int]struct{}
	clearedcreated_users   bool
	updated_by_user        *int
	clearedupdated_by_user bool
	updated_users          map[int]struct{}
	removedupdated_users   map[int]struct{}
	clearedupdated_users   bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *UserMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *UserMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *UserMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[user.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *UserMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[user.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *UserMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, user.FieldDateOfBirth)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetCurrentAddress sets the "current_address" field.
func (m *UserMutation) SetCurrentAddress(s string) {
	m.current_address = &s
}

// CurrentAddress returns the value of the "current_address" field in the mutation.
func (m *UserMutation) CurrentAddress() (r string, exists bool) {
	v := m.current_address
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentAddress returns the old "current_address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrentAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentAddress: %w", err)
	}
	return oldValue.CurrentAddress, nil
}

// ClearCurrentAddress clears the value of the "current_address" field.
func (m *UserMutation) ClearCurrentAddress() {
	m.current_address = nil
	m.clearedFields[user.FieldCurrentAddress] = struct{}{}
}

// CurrentAddressCleared returns if the "current_address" field was cleared in this mutation.
func (m *UserMutation) CurrentAddressCleared() bool {
	_, ok := m.clearedFields[user.FieldCurrentAddress]
	return ok
}

// ResetCurrentAddress resets all changes to the "current_address" field.
func (m *UserMutation) ResetCurrentAddress() {
	m.current_address = nil
	delete(m.clearedFields, user.FieldCurrentAddress)
}

// SetPermanentAddress sets the "permanent_address" field.
func (m *UserMutation) SetPermanentAddress(s string) {
	m.permanent_address = &s
}

// PermanentAddress returns the value of the "permanent_address" field in the mutation.
func (m *UserMutation) PermanentAddress() (r string, exists bool) {
	v := m.permanent_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPermanentAddress returns the old "permanent_address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPermanentAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermanentAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermanentAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermanentAddress: %w", err)
	}
	return oldValue.PermanentAddress, nil
}

// ClearPermanentAddress clears the value of the "permanent_address" field.
func (m *UserMutation) ClearPermanentAddress() {
	m.permanent_address = nil
	m.clearedFields[user.FieldPermanentAddress] = struct{}{}
}

// PermanentAddressCleared returns if the "permanent_address" field was cleared in this mutation.
func (m *UserMutation) PermanentAddressCleared() bool {
	_, ok := m.clearedFields[user.FieldPermanentAddress]
	return ok
}

// ResetPermanentAddress resets all changes to the "permanent_address" field.
func (m *UserMutation) ResetPermanentAddress() {
	m.permanent_address = nil
	delete(m.clearedFields, user.FieldPermanentAddress)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *UserMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *UserMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *UserMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetIsEmailVerified sets the "is_email_verified" field.
func (m *UserMutation) SetIsEmailVerified(b bool) {
	m.is_email_verified = &b
}

// IsEmailVerified returns the value of the "is_email_verified" field in the mutation.
func (m *UserMutation) IsEmailVerified() (r bool, exists bool) {
	v := m.is_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEmailVerified returns the old "is_email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEmailVerified: %w", err)
	}
	return oldValue.IsEmailVerified, nil
}

// ResetIsEmailVerified resets all changes to the "is_email_verified" field.
func (m *UserMutation) ResetIsEmailVerified() {
	m.is_email_verified = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *UserMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetLastLoginTime sets the "last_login_time" field.
func (m *UserMutation) SetLastLoginTime(t time.Time) {
	m.last_login_time = &t
}

// LastLoginTime returns the value of the "last_login_time" field in the mutation.
func (m *UserMutation) LastLoginTime() (r time.Time, exists bool) {
	v := m.last_login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginTime returns the old "last_login_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginTime: %w", err)
	}
	return oldValue.LastLoginTime, nil
}

// ClearLastLoginTime clears the value of the "last_login_time" field.
func (m *UserMutation) ClearLastLoginTime() {
	m.last_login_time = nil
	m.clearedFields[user.FieldLastLoginTime] = struct{}{}
}

// LastLoginTimeCleared returns if the "last_login_time" field was cleared in this mutation.
func (m *UserMutation) LastLoginTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginTime]
	return ok
}

// ResetLastLoginTime resets all changes to the "last_login_time" field.
func (m *UserMutation) ResetLastLoginTime() {
	m.last_login_time = nil
	delete(m.clearedFields, user.FieldLastLoginTime)
}

// SetParentID sets the "parent_id" field.
func (m *UserMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *UserMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *UserMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *UserMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *UserMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[user.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *UserMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[user.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *UserMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, user.FieldParentID)
}

// SetPhotoURL sets the "photo_url" field.
func (m *UserMutation) SetPhotoURL(s string) {
	m.photo_url = &s
}

// PhotoURL returns the value of the "photo_url" field in the mutation.
func (m *UserMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ClearPhotoURL clears the value of the "photo_url" field.
func (m *UserMutation) ClearPhotoURL() {
	m.photo_url = nil
	m.clearedFields[user.FieldPhotoURL] = struct{}{}
}

// PhotoURLCleared returns if the "photo_url" field was cleared in this mutation.
func (m *UserMutation) PhotoURLCleared() bool {
	_, ok := m.clearedFields[user.FieldPhotoURL]
	return ok
}

// ResetPhotoURL resets all changes to the "photo_url" field.
func (m *UserMutation) ResetPhotoURL() {
	m.photo_url = nil
	delete(m.clearedFields, user.FieldPhotoURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// AddUpdatedBlogIDs adds the "updated_blogs" edge to the Blogs entity by ids.
func (m *UserMutation) AddUpdatedBlogIDs(ids ...int) {
	if m.updated_blogs == nil {
		m.updated_blogs = make(map[int]struct{})
	}
	for i := range ids {
		m.updated_blogs[ids[i]] = struct{}{}
	}
}

// ClearUpdatedBlogs clears the "updated_blogs" edge to the Blogs entity.
func (m *UserMutation) ClearUpdatedBlogs() {
	m.clearedupdated_blogs = true
}

// UpdatedBlogsCleared reports if the "updated_blogs" edge to the Blogs entity was cleared.
func (m *UserMutation) UpdatedBlogsCleared() bool {
	return m.clearedupdated_blogs
}

// RemoveUpdatedBlogIDs removes the "updated_blogs" edge to the Blogs entity by IDs.
func (m *UserMutation) RemoveUpdatedBlogIDs(ids ...int) {
	if m.removedupdated_blogs == nil {
		m.removedupdated_blogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updated_blogs, ids[i])
		m.removedupdated_blogs[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedBlogs returns the removed IDs of the "updated_blogs" edge to the Blogs entity.
func (m *UserMutation) RemovedUpdatedBlogsIDs() (ids []int) {
	for id := range m.removedupdated_blogs {
		ids = append(ids, id)
	}
	return
}

// UpdatedBlogsIDs returns the "updated_blogs" edge IDs in the mutation.
func (m *UserMutation) UpdatedBlogsIDs() (ids []int) {
	for id := range m.updated_blogs {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedBlogs resets all changes to the "updated_blogs" edge.
func (m *UserMutation) ResetUpdatedBlogs() {
	m.updated_blogs = nil
	m.clearedupdated_blogs = false
	m.removedupdated_blogs = nil
}

// SetCreatedByUserID sets the "created_by_user" edge to the User entity by id.
func (m *UserMutation) SetCreatedByUserID(id int) {
	m.created_by_user = &id
}

// ClearCreatedByUser clears the "created_by_user" edge to the User entity.
func (m *UserMutation) ClearCreatedByUser() {
	m.clearedcreated_by_user = true
}

// CreatedByUserCleared reports if the "created_by_user" edge to the User entity was cleared.
func (m *UserMutation) CreatedByUserCleared() bool {
	return m.clearedcreated_by_user
}

// CreatedByUserID returns the "created_by_user" edge ID in the mutation.
func (m *UserMutation) CreatedByUserID() (id int, exists bool) {
	if m.created_by_user != nil {
		return *m.created_by_user, true
	}
	return
}

// CreatedByUserIDs returns the "created_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByUserID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreatedByUserIDs() (ids []int) {
	if id := m.created_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByUser resets all changes to the "created_by_user" edge.
func (m *UserMutation) ResetCreatedByUser() {
	m.created_by_user = nil
	m.clearedcreated_by_user = false
}

// AddCreatedUserIDs adds the "created_users" edge to the User entity by ids.
func (m *UserMutation) AddCreatedUserIDs(ids ...int) {
	if m.created_users == nil {
		m.created_users = make(map[int]struct{})
	}
	for i := range ids {
		m.created_users[ids[i]] = struct{}{}
	}
}

// ClearCreatedUsers clears the "created_users" edge to the User entity.
func (m *UserMutation) ClearCreatedUsers() {
	m.clearedcreated_users = true
}

// CreatedUsersCleared reports if the "created_users" edge to the User entity was cleared.
func (m *UserMutation) CreatedUsersCleared() bool {
	return m.clearedcreated_users
}

// RemoveCreatedUserIDs removes the "created_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreatedUserIDs(ids ...int) {
	if m.removedcreated_users == nil {
		m.removedcreated_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_users, ids[i])
		m.removedcreated_users[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUsers returns the removed IDs of the "created_users" edge to the User entity.
func (m *UserMutation) RemovedCreatedUsersIDs() (ids []int) {
	for id := range m.removedcreated_users {
		ids = append(ids, id)
	}
	return
}

// CreatedUsersIDs returns the "created_users" edge IDs in the mutation.
func (m *UserMutation) CreatedUsersIDs() (ids []int) {
	for id := range m.created_users {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUsers resets all changes to the "created_users" edge.
func (m *UserMutation) ResetCreatedUsers() {
	m.created_users = nil
	m.clearedcreated_users = false
	m.removedcreated_users = nil
}

// SetUpdatedByUserID sets the "updated_by_user" edge to the User entity by id.
func (m *UserMutation) SetUpdatedByUserID(id int) {
	m.updated_by_user = &id
}

// ClearUpdatedByUser clears the "updated_by_user" edge to the User entity.
func (m *UserMutation) ClearUpdatedByUser() {
	m.clearedupdated_by_user = true
}

// UpdatedByUserCleared reports if the "updated_by_user" edge to the User entity was cleared.
func (m *UserMutation) UpdatedByUserCleared() bool {
	return m.clearedupdated_by_user
}

// UpdatedByUserID returns the "updated_by_user" edge ID in the mutation.
func (m *UserMutation) UpdatedByUserID() (id int, exists bool) {
	if m.updated_by_user != nil {
		return *m.updated_by_user, true
	}
	return
}

// UpdatedByUserIDs returns the "updated_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByUserID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UpdatedByUserIDs() (ids []int) {
	if id := m.updated_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedByUser resets all changes to the "updated_by_user" edge.
func (m *UserMutation) ResetUpdatedByUser() {
	m.updated_by_user = nil
	m.clearedupdated_by_user = false
}

// AddUpdatedUserIDs adds the "updated_users" edge to the User entity by ids.
func (m *UserMutation) AddUpdatedUserIDs(ids ...int) {
	if m.updated_users == nil {
		m.updated_users = make(map[int]struct{})
	}
	for i := range ids {
		m.updated_users[ids[i]] = struct{}{}
	}
}

// ClearUpdatedUsers clears the "updated_users" edge to the User entity.
func (m *UserMutation) ClearUpdatedUsers() {
	m.clearedupdated_users = true
}

// UpdatedUsersCleared reports if the "updated_users" edge to the User entity was cleared.
func (m *UserMutation) UpdatedUsersCleared() bool {
	return m.clearedupdated_users
}

// RemoveUpdatedUserIDs removes the "updated_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveUpdatedUserIDs(ids ...int) {
	if m.removedupdated_users == nil {
		m.removedupdated_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updated_users, ids[i])
		m.removedupdated_users[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedUsers returns the removed IDs of the "updated_users" edge to the User entity.
func (m *UserMutation) RemovedUpdatedUsersIDs() (ids []int) {
	for id := range m.removedupdated_users {
		ids = append(ids, id)
	}
	return
}

// UpdatedUsersIDs returns the "updated_users" edge IDs in the mutation.
func (m *UserMutation) UpdatedUsersIDs() (ids []int) {
	for id := range m.updated_users {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedUsers resets all changes to the "updated_users" edge.
func (m *UserMutation) ResetUpdatedUsers() {
	m.updated_users = nil
	m.clearedupdated_users = false
	m.removedupdated_users = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.date_of_birth != nil {
		fields = append(fields, user.FieldDateOfBirth)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.current_address != nil {
		fields = append(fields, user.FieldCurrentAddress)
	}
	if m.permanent_address != nil {
		fields = append(fields, user.FieldPermanentAddress)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.is_deleted != nil {
		fields = append(fields, user.FieldIsDeleted)
	}
	if m.is_email_verified != nil {
		fields = append(fields, user.FieldIsEmailVerified)
	}
	if m.is_verified != nil {
		fields = append(fields, user.FieldIsVerified)
	}
	if m.last_login_time != nil {
		fields = append(fields, user.FieldLastLoginTime)
	}
	if m.parent_id != nil {
		fields = append(fields, user.FieldParentID)
	}
	if m.photo_url != nil {
		fields = append(fields, user.FieldPhotoURL)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldDateOfBirth:
		return m.DateOfBirth()
	case user.FieldGender:
		return m.Gender()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldCurrentAddress:
		return m.CurrentAddress()
	case user.FieldPermanentAddress:
		return m.PermanentAddress()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldIsDeleted:
		return m.IsDeleted()
	case user.FieldIsEmailVerified:
		return m.IsEmailVerified()
	case user.FieldIsVerified:
		return m.IsVerified()
	case user.FieldLastLoginTime:
		return m.LastLoginTime()
	case user.FieldParentID:
		return m.ParentID()
	case user.FieldPhotoURL:
		return m.PhotoURL()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldCurrentAddress:
		return m.OldCurrentAddress(ctx)
	case user.FieldPermanentAddress:
		return m.OldPermanentAddress(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case user.FieldIsEmailVerified:
		return m.OldIsEmailVerified(ctx)
	case user.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case user.FieldLastLoginTime:
		return m.OldLastLoginTime(ctx)
	case user.FieldParentID:
		return m.OldParentID(ctx)
	case user.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case user.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldCurrentAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentAddress(v)
		return nil
	case user.FieldPermanentAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermanentAddress(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case user.FieldIsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEmailVerified(v)
		return nil
	case user.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case user.FieldLastLoginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginTime(v)
		return nil
	case user.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case user.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addparent_id != nil {
		fields = append(fields, user.FieldParentID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldParentID:
		return m.AddedParentID()
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDateOfBirth) {
		fields = append(fields, user.FieldDateOfBirth)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldCurrentAddress) {
		fields = append(fields, user.FieldCurrentAddress)
	}
	if m.FieldCleared(user.FieldPermanentAddress) {
		fields = append(fields, user.FieldPermanentAddress)
	}
	if m.FieldCleared(user.FieldLastLoginTime) {
		fields = append(fields, user.FieldLastLoginTime)
	}
	if m.FieldCleared(user.FieldParentID) {
		fields = append(fields, user.FieldParentID)
	}
	if m.FieldCleared(user.FieldPhotoURL) {
		fields = append(fields, user.FieldPhotoURL)
	}
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldCurrentAddress:
		m.ClearCurrentAddress()
		return nil
	case user.FieldPermanentAddress:
		m.ClearPermanentAddress()
		return nil
	case user.FieldLastLoginTime:
		m.ClearLastLoginTime()
		return nil
	case user.FieldParentID:
		m.ClearParentID()
		return nil
	case user.FieldPhotoURL:
		m.ClearPhotoURL()
		return nil
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldCurrentAddress:
		m.ResetCurrentAddress()
		return nil
	case user.FieldPermanentAddress:
		m.ResetPermanentAddress()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case user.FieldIsEmailVerified:
		m.ResetIsEmailVerified()
		return nil
	case user.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case user.FieldLastLoginTime:
		m.ResetLastLoginTime()
		return nil
	case user.FieldParentID:
		m.ResetParentID()
		return nil
	case user.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.updated_blogs != nil {
		edges = append(edges, user.EdgeUpdatedBlogs)
	}
	if m.created_by_user != nil {
		edges = append(edges, user.EdgeCreatedByUser)
	}
	if m.created_users != nil {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.updated_by_user != nil {
		edges = append(edges, user.EdgeUpdatedByUser)
	}
	if m.updated_users != nil {
		edges = append(edges, user.EdgeUpdatedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUpdatedBlogs:
		ids := make([]ent.Value, 0, len(m.updated_blogs))
		for id := range m.updated_blogs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedByUser:
		if id := m.created_by_user; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedUsers:
		ids := make([]ent.Value, 0, len(m.created_users))
		for id := range m.created_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedByUser:
		if id := m.updated_by_user; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUpdatedUsers:
		ids := make([]ent.Value, 0, len(m.updated_users))
		for id := range m.updated_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedupdated_blogs != nil {
		edges = append(edges, user.EdgeUpdatedBlogs)
	}
	if m.removedcreated_users != nil {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.removedupdated_users != nil {
		edges = append(edges, user.EdgeUpdatedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUpdatedBlogs:
		ids := make([]ent.Value, 0, len(m.removedupdated_blogs))
		for id := range m.removedupdated_blogs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUsers:
		ids := make([]ent.Value, 0, len(m.removedcreated_users))
		for id := range m.removedcreated_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedUsers:
		ids := make([]ent.Value, 0, len(m.removedupdated_users))
		for id := range m.removedupdated_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedupdated_blogs {
		edges = append(edges, user.EdgeUpdatedBlogs)
	}
	if m.clearedcreated_by_user {
		edges = append(edges, user.EdgeCreatedByUser)
	}
	if m.clearedcreated_users {
		edges = append(edges, user.EdgeCreatedUsers)
	}
	if m.clearedupdated_by_user {
		edges = append(edges, user.EdgeUpdatedByUser)
	}
	if m.clearedupdated_users {
		edges = append(edges, user.EdgeUpdatedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUpdatedBlogs:
		return m.clearedupdated_blogs
	case user.EdgeCreatedByUser:
		return m.clearedcreated_by_user
	case user.EdgeCreatedUsers:
		return m.clearedcreated_users
	case user.EdgeUpdatedByUser:
		return m.clearedupdated_by_user
	case user.EdgeUpdatedUsers:
		return m.clearedupdated_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCreatedByUser:
		m.ClearCreatedByUser()
		return nil
	case user.EdgeUpdatedByUser:
		m.ClearUpdatedByUser()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUpdatedBlogs:
		m.ResetUpdatedBlogs()
		return nil
	case user.EdgeCreatedByUser:
		m.ResetCreatedByUser()
		return nil
	case user.EdgeCreatedUsers:
		m.ResetCreatedUsers()
		return nil
	case user.EdgeUpdatedByUser:
		m.ResetUpdatedByUser()
		return nil
	case user.EdgeUpdatedUsers:
		m.ResetUpdatedUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
